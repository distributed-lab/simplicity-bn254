// Big 256-bit number that is represented with a tuple of 4 u64 values.
// This is an auxiliary alias just for representing a tuple of u64.
type BigNum = (u64, u64, u64, u64);

// Field element that is represented with a BigNum value and modulus.
type FieldElement = (BigNum, BigNum);

#define qInvNeg 9786893198990664585

// Fp prime field modulus. 
//  - base 10: 21888242871839275222246405745257275088696311157297823662689037894645226208583
//  - base 16: 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD47
fn fp_mod() -> u256 {
    21888242871839275222246405745257275088696311157297823662689037894645226208583
}

// Creates new Fp with the provided value.
// Note that it is not checked whether the provided value is less then the fp_mod().
fn fp_new(value: u256) -> FieldElement {
    (<u256>::into(value), <u256>::into(fp_mod()))
}

// Fr prime field modulus. 
//  - base 10: 21888242871839275222246405745257275088548364400416034343698204186575808495617
//  - base 16: 0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001
fn fr_mod() -> u256 {
    21888242871839275222246405745257275088548364400416034343698204186575808495617
}

// Creates new Fr with the provided value.
// Note that it is not checked whether the provided value is less then the fr_mod().
fn fr_new(value: u256) -> FieldElement {
    (<u256>::into(value), <u256>::into(fr_mod()))
}

// Decomposes FieldElement into 256-bit value and corresponding modulus.
fn field_elem_decompose(big_num: FieldElement) -> (u256, u256) {
    let (value, module): (BigNum, BigNum) = big_num;
    (<BigNum>::into(value), <BigNum>::into(module))
}

// Returns true if the provided value is less then the FieldElement modulus.
fn field_elem_smaller_then_modulus(field_element: FieldElement) -> bool {
    let ((v0, v1, v2, v3), (q0, q1, q2, q3)): ((u64, u64, u64, u64), (u64, u64, u64, u64)) = field_element;

    let v3_lt_q3: u1 = <bool>::into(jet::lt_64(v3, q3));
    let v2_eq_q2: u1 = <bool>::into(jet::eq_64(v2, q2));

    let v2_lt_q2: u1 = <bool>::into(jet::lt_64(v2, q2));
    let v1_eq_q1: u1 = <bool>::into(jet::eq_64(v1, q1));

    let v1_lt_q1: u1 = <bool>::into(jet::lt_64(v1, q1));
    let v0_eq_q0: u1 = <bool>::into(jet::eq_64(v0, q0));

    let v0_lt_q0: u1 = <bool>::into(jet::lt_64(v0, q0));

    let v2_and_v3: u1 = jet::and_1(v2_eq_q2, v3_lt_q3);
    let v2_or_v2: u1 = jet::or_1(v2_lt_q2, v2_and_v3);

    let v1_and_v2: u1 = jet::and_1(v1_eq_q1, v2_or_v2);
    let v1_or_v1: u1 = jet::or_1(v1_lt_q1, v1_and_v2);

    let v0_and_v1: u1 = jet::and_1(v0_eq_q0, v1_or_v1);
    let v0_or_v0: u1 = jet::or_1(v0_lt_q0, v0_and_v1);

    <u1>::into(v0_or_v0)
}

// Returns true if the provided value is zero.
fn field_elem_is_zero(x: FieldElement) -> bool {
    let ((x0, x1, x2, x3), _): ((u64, u64, u64, u64), BigNum) = x;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, 0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, 0));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, 0));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, 0));

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}

// Returns true if value x is equal to value y.
//
// Note that it compares only internal values, not modulus.
fn field_elem_eq(x: FieldElement, y: FieldElement) -> bool {
    let ((x0, x1, x2, x3), _): ((u64, u64, u64, u64), BigNum) = x;
    let ((y0, y1, y2, y3), _): ((u64, u64, u64, u64), BigNum) = y;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, y0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, y1));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, y2));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, y3));

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}

// Returns the sum of provided x and y values taken by group modulus.
//
// We assume by default that the provided field elements have the same modulus.
// So, the corresponding check is not provided in order to save the program space 
// and the number of operations. If overflow happens, the first element modulus
// is taken.
//
// y = (x + y) mod q
fn field_elem_add(x: FieldElement, y: FieldElement) -> FieldElement {
    let ((x0, x1, x2, x3), x_mod): ((u64, u64, u64, u64), BigNum) = x;
    let ((y0, y1, y2, y3), _): ((u64, u64, u64, u64), BigNum) = y;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, y1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, y0);

    match field_elem_smaller_then_modulus(((r0, r1, r2, r3), x_mod)) {
        true => ((r0, r1, r2, r3), x_mod),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = x_mod;
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            ((s0, s1, s2, s3), x_mod)
        },
    }
}

// Returns the double of provided x value taken by group modulus.
//
// y = (x + x) mod q
fn field_elem_double(x: FieldElement) -> FieldElement {
    let ((x0, x1, x2, x3), x_mod): ((u64, u64, u64, u64), BigNum) = x;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, x3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, x2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, x1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, x0);

    match field_elem_smaller_then_modulus(((r0, r1, r2, r3), x_mod)) {
        true => ((r0, r1, r2, r3), x_mod),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = x_mod;
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            ((s0, s1, s2, s3), x_mod)
        },
    }
}

// Returns the subtraction of provided x and y values taken by group modulus.
//
// We assume by default that the provided field elements have the same modulus.
// So, the corresponding check is not provided in order to save the program space 
// and the number of operations. If overflow happens, the first element modulus
// is taken.
//
// y = (x - y) mod q
fn field_elem_sub(x: FieldElement, y: FieldElement) -> FieldElement {
    let ((x0, x1, x2, x3), x_mod): ((u64, u64, u64, u64), BigNum) = x;
    let ((y0, y1, y2, y3), _): ((u64, u64, u64, u64), BigNum) = y;

    let (carry, r3): (bool, u64) = jet::full_subtract_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_subtract_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_subtract_64(carry, x1, y1);
    let (carry, r0): (bool, u64) = jet::full_subtract_64(carry, x0, y0);

    match carry {
        false => ((r0, r1, r2, r3), x_mod),
        true => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = x_mod;
            let (carry, s3): (bool, u64) = jet::full_add_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_add_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_add_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_add_64(carry, r0, m0);

            ((s0, s1, s2, s3), x_mod)
        },
    }
}

// Takes negation of the provided value by subtracting the value from the group modulus.
//
// y = q - x
fn field_elem_neg(x: FieldElement) -> FieldElement {
    match field_elem_is_zero(x) {
        true => x,
        false => {
            let ((x0, x1, x2, x3), x_mod): ((u64, u64, u64, u64), BigNum) = x;
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = x_mod;

            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, m3, x3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, m2, x2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, m1, x1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, m0, x0);

            ((s0, s1, s2, s3), x_mod)
        }
    }
}

fn field_elem_q_inv_mul(
    c2: u64,
    q0: u64, q1: u64, q2: u64, q3: u64,
    t0: u64, t1: u64, t2: u64, t3: u64
) -> ((u64, u64, u64, u64), (u64, u64, u64, u64)) {
    let (_, m1): (u64, u64) = <u128>::into(jet::full_multiply_64((qInvNeg, t0), (0, 0)));

    let (u0, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q3), (0, 0)));
    let (c0, _): (bool, u64) = jet::full_add_64(false, t0, c1);
    let (u1, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q2), (0, 0)));
    let (c0, t0): (bool, u64) = jet::full_add_64(c0, t1, c1);
    let (u2, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q1), (0, 0)));
    let (c0, t1): (bool, u64) = jet::full_add_64(c0, t2, c1);
    let (u3, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q0), (0, 0)));

    let (c0, t2): (bool, u64) = jet::full_add_64(c0, 0, c1);
    let (_, u3): (bool, u64) = jet::full_add_64(c0, u3, 0);
    let (c0, t0): (bool, u64) = jet::full_add_64(false, u0, t0);
    let (c0, t1): (bool, u64) = jet::full_add_64(c0, u1, t1);
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, u2, t2);
    let (_, c2): (bool, u64) = jet::full_add_64(c0, c2, 0);
    let (c0, t2): (bool, u64) = jet::full_add_64(false, t3, t2);
    let (_, t3): (bool, u64) = jet::full_add_64(c0, u3, c2);

    ((u0, u1, u2, u3), (t0, t1, t2, t3))
}

fn field_elem_process_x_mul(
    x: u64, 
    y0: u64, y1: u64, y2: u64, y3: u64, 
    t0: u64, t1: u64, t2: u64, t3: u64,
    q0: u64, q1: u64, q2: u64, q3: u64
) -> ((u64, u64, u64, u64), (u64, u64, u64, u64)) {
    let (u0, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y3), (0, 0)));
    let (c0, t0): (bool, u64) = jet::full_add_64(false, c1, t0);
    let (u1, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y2), (0, 0)));
    let (c0, t1): (bool, u64) = jet::full_add_64(c0, c1, t1);
    let (u2, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y1), (0, 0)));
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, c1, t2);
    let (u3, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y0), (0, 0)));
    let (c0, t3): (bool, u64) = jet::full_add_64(c0, c1, t3);

    let (_, c2): (bool, u64) = jet::full_add_64(c0, 0, 0);
    let (c0, t1): (bool, u64) = jet::full_add_64(false, u0, t1);
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, u1, t2);
    let (c0, t3): (bool, u64) = jet::full_add_64(c0, u2, t3);
    let (_, c2): (bool, u64) = jet::full_add_64(c0, u3, c2);

    (field_elem_q_inv_mul(c2, q0, q1, q2, q3, t0, t1, t2, t3))
}

fn field_elem_mul(x: FieldElement, y: FieldElement) -> FieldElement {
    let ((x0, x1, x2, x3), x_mod): ((u64, u64, u64, u64), BigNum) = x;
    let ((y0, y1, y2, y3), _): ((u64, u64, u64, u64), BigNum) = y;
    let (q0, q1, q2, q3): (u64, u64, u64, u64) = x_mod;

    // TODO: lets brake down this part into several functions
    // Process x3
    let (u0, t0): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y3), (0, 0)));
    let (u1, t1): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y2), (0, 0)));
    let (u2, t2): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y1), (0, 0)));
    let (u3, t3): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y0), (0, 0)));
    let (c0, t1): (bool, u64) = jet::full_add_64(false, u0, t1);
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, u1, t2);
    let (c0, t3): (bool, u64) = jet::full_add_64(c0, u2, t3);
    let (_, c2): (bool, u64) = jet::full_add_64(c0, u3, 0);

    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_elem_q_inv_mul(c2, q0, q1, q2, q3, t0, t1, t2, t3);

    // Process x2
    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_elem_process_x_mul(x2, y0, y1, y2, y3, t0, t1, t2, t3, q0, q1, q2, q3);

    // Process x1
    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_elem_process_x_mul(x1, y0, y1, y2, y3, t0, t1, t2, t3, q0, q1, q2, q3);

    // Process x0
    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_elem_process_x_mul(x0, y0, y1, y2, y3, t0, t1, t2, t3, q0, q1, q2, q3);

    match field_elem_smaller_then_modulus(((t3, t2, t1, t0), x_mod)) {
        true => ((t0, t1, t2, t3), x_mod),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = x_mod;
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, t3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, t2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, t1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, t0, m0);

            ((s0, s1, s2, s3), x_mod)
        },
    }
}

#ifdef TESTING

fn test_field_elem_add_mod() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fr_new(200);
    let actual_1limb: FieldElement = field_elem_add(fr_new(100), fr_new(100));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_1limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_1limb));

    assert!(field_elem_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fr_new(4567623456734502163058672543468019698188889198785079926);
    let actual_3limb: FieldElement = field_elem_add(
        fr_new(4567623456734423769034092193793479852479845689346389469), 
        fr_new(78394024580349674539845709043509438690457)
    );

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_3limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_3limb));

    assert!(field_elem_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: FieldElement = fr_new(100);
    let actual_overflow: FieldElement = field_elem_add(fr_new(fr_mod()), fr_new(100));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_overflow));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_overflow));

    assert!(field_elem_eq(expected_overflow, actual_overflow))   
}

fn test_field_elem_double_mod() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fr_new(200);
    let actual_1limb: FieldElement = field_elem_double(fr_new(100));


    let _: (u256, u256) = dbg!(field_elem_decompose(expected_1limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_1limb));

    assert!(field_elem_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fr_new(9135246913468847538068184387586959704959691378692778938);
    let actual_3limb: FieldElement = field_elem_double(fr_new(4567623456734423769034092193793479852479845689346389469));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_3limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_3limb));

    assert!(field_elem_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: FieldElement = fr_new(21888242871839275222246405745257275088548364400416034343698204186575808495617);
    let actual_overflow: FieldElement = field_elem_double(fr_new(fr_mod()));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_overflow));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_overflow));

    assert!(field_elem_eq(expected_overflow, actual_overflow))   
}

fn test_field_elem_sub_mod() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fr_new(100);
    let actual_1limb: FieldElement = field_elem_sub(fr_new(200), fr_new(100));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_1limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_1limb));

    assert!(field_elem_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fr_new(4567623456734345375009511844118940006770802179907699012);
    let actual_3limb: FieldElement = field_elem_sub(
        fr_new(4567623456734423769034092193793479852479845689346389469), 
        fr_new(78394024580349674539845709043509438690457)
    );

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_3limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_3limb));

    assert!(field_elem_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: FieldElement = fr_new(100);
    let actual_overflow: FieldElement = field_elem_sub(fr_new(100), fr_new(fr_mod()));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_overflow));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_overflow));

    assert!(field_elem_eq(expected_overflow, actual_overflow))   
}

fn test_field_elem_num_is_zero() {
    // Zero as parameter
    assert!(field_elem_is_zero(fr_new(0)));

    // One limb is not zero 
    let is_zero: bool = field_elem_is_zero(fr_new(18446744073709551616));
    assert!(<u1>::into(jet::complement_1(<bool>::into(is_zero))))
}

fn test_field_elem_neg() {
    // Negate zero
    let expected_zero: FieldElement = fr_new(0);
    let actual_zero: FieldElement = field_elem_neg(fr_new(0));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_zero));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_zero));

    assert!(field_elem_eq(actual_zero, expected_zero));

    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fr_new(21888242871839275222246405745257275088548364400416034343698204186575808495517);
    let actual_1limb: FieldElement = field_elem_neg(fr_new(100));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_1limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_1limb));

    assert!(field_elem_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fr_new(21888242871839275222241838121800540664779330308222240863845724340886462106148);
    let actual_3limb: FieldElement = field_elem_neg(fr_new(4567623456734423769034092193793479852479845689346389469));

    let _: (u256, u256) = dbg!(field_elem_decompose(expected_3limb));
    let _: (u256, u256) = dbg!(field_elem_decompose(actual_3limb));

    assert!(field_elem_eq(expected_3limb, actual_3limb));
}

#endif
