// Prime field zero in Montgomery form
#define FIELD_ZERO (0, 0, 0, 0)

// Big 256-bit number that is represented with a tuple of 4 u64 values.
// This is an auxiliary alias just for representing a tuple of u64.
type FieldElement = (u64, u64, u64, u64);

fn field_element_new(value: u256) -> FieldElement {
    <u256>::into(value)
}

// Fr prime field modulus. 
//  - base 10: 21888242871839275222246405745257275088548364400416034343698204186575808495617
//  - base 16: 0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001
fn fr_mod() -> u256 {
    21888242871839275222246405745257275088548364400416034343698204186575808495617
}


// Decomposes FieldElement into 256-bit value and corresponding modulus.
fn field_element_decompose(field_element: FieldElement) -> u256 {
    <FieldElement>::into(field_element)
}

// TODO: rename FieldElement to BigInt

// Returns true if the provided value is less then the FieldElement modulus.
fn field_element_smaller_then_modulus(field_element: FieldElement, modulus: FieldElement) -> bool {
    let (v0, v1, v2, v3): (u64, u64, u64, u64) = field_element;
    let (q0, q1, q2, q3): (u64, u64, u64, u64) = modulus;

    let v3_lt_q3: u1 = <bool>::into(jet::lt_64(v3, q3));
    let v2_eq_q2: u1 = <bool>::into(jet::eq_64(v2, q2));

    let v2_lt_q2: u1 = <bool>::into(jet::lt_64(v2, q2));
    let v1_eq_q1: u1 = <bool>::into(jet::eq_64(v1, q1));

    let v1_lt_q1: u1 = <bool>::into(jet::lt_64(v1, q1));
    let v0_eq_q0: u1 = <bool>::into(jet::eq_64(v0, q0));

    let v0_lt_q0: u1 = <bool>::into(jet::lt_64(v0, q0));

    let v2_and_v3: u1 = jet::and_1(v2_eq_q2, v3_lt_q3);
    let v2_or_v2: u1 = jet::or_1(v2_lt_q2, v2_and_v3);

    let v1_and_v2: u1 = jet::and_1(v1_eq_q1, v2_or_v2);
    let v1_or_v1: u1 = jet::or_1(v1_lt_q1, v1_and_v2);

    let v0_and_v1: u1 = jet::and_1(v0_eq_q0, v1_or_v1);
    let v0_or_v0: u1 = jet::or_1(v0_lt_q0, v0_and_v1);

    <u1>::into(v0_or_v0)
}

// Returns true if the provided value is zero.
fn field_element_is_zero(x: FieldElement) -> bool {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, 0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, 0));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, 0));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, 0));

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}

// Returns true if value x is equal to value y.
//
// Note that it compares only internal values, not modulus.
fn field_element_eq(x: FieldElement, y: FieldElement) -> bool {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, y0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, y1));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, y2));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, y3));

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}

// Returns the sum of provided x and y values taken by group modulus.
//
// We assume by default that the provided field elements have the same modulus.
// So, the corresponding check is not provided in order to save the program space 
// and the number of operations. If overflow happens, the first element modulus
// is taken.
//
// y = (x + y) mod q
fn field_element_add(x: FieldElement, y: FieldElement, modulus: FieldElement) -> FieldElement {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, y1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, y0);

    match field_element_smaller_then_modulus((r0, r1, r2, r3), modulus) {
        true => (r0, r1, r2, r3),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = modulus;
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Returns the double of provided x value taken by group modulus.
//
// y = (x + x) mod q
fn field_element_double(x: FieldElement, modulus: FieldElement) -> FieldElement {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, x3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, x2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, x1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, x0);

    match field_element_smaller_then_modulus((r0, r1, r2, r3), modulus) {
        true => (r0, r1, r2, r3),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = modulus;
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Returns the subtraction of provided x and y values taken by group modulus.
//
// We assume by default that the provided field elements have the same modulus.
// So, the corresponding check is not provided in order to save the program space 
// and the number of operations. If overflow happens, the first element modulus
// is taken.
//
// y = (x - y) mod q
fn field_element_sub(x: FieldElement, y: FieldElement, modulus: FieldElement) -> FieldElement {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let (carry, r3): (bool, u64) = jet::full_subtract_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_subtract_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_subtract_64(carry, x1, y1);
    let (carry, r0): (bool, u64) = jet::full_subtract_64(carry, x0, y0);

    match carry {
        false => (r0, r1, r2, r3),
        true => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = modulus;
            let (carry, s3): (bool, u64) = jet::full_add_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_add_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_add_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_add_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Takes negation of the provided value by subtracting the value from the group modulus.
//
// y = q - x
fn field_element_neg(x: FieldElement, modulus: FieldElement) -> FieldElement {
    match field_element_is_zero(x) {
        true => x,
        false => {
            let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = modulus;

            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, m3, x3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, m2, x2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, m1, x1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, m0, x0);

            (s0, s1, s2, s3)
        }
    }
}

fn field_element_q_inv_mul(
    c2: u64,
    q0: u64, q1: u64, q2: u64, q3: u64,
    t0: u64, t1: u64, t2: u64, t3: u64,
    qInvNeg: u64
) -> ((u64, u64, u64, u64), (u64, u64, u64, u64)) {
    let (_, m1): (u64, u64) = <u128>::into(jet::full_multiply_64((qInvNeg, t0), (0, 0)));

    let (u0, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q3), (0, 0)));
    let (c0, _): (bool, u64) = jet::full_add_64(false, t0, c1);
    let (u1, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q2), (0, 0)));
    let (c0, t0): (bool, u64) = jet::full_add_64(c0, t1, c1);
    let (u2, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q1), (0, 0)));
    let (c0, t1): (bool, u64) = jet::full_add_64(c0, t2, c1);
    let (u3, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((m1, q0), (0, 0)));

    let (c0, t2): (bool, u64) = jet::full_add_64(c0, 0, c1);
    let (_, u3): (bool, u64) = jet::full_add_64(c0, u3, 0);
    let (c0, t0): (bool, u64) = jet::full_add_64(false, u0, t0);
    let (c0, t1): (bool, u64) = jet::full_add_64(c0, u1, t1);
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, u2, t2);
    let (_, c2): (bool, u64) = jet::full_add_64(c0, c2, 0);
    let (c0, t2): (bool, u64) = jet::full_add_64(false, t3, t2);
    let (_, t3): (bool, u64) = jet::full_add_64(c0, u3, c2);

    ((u0, u1, u2, u3), (t0, t1, t2, t3))
}

fn field_element_process_x_mul(
    x: u64, 
    y0: u64, y1: u64, y2: u64, y3: u64, 
    t0: u64, t1: u64, t2: u64, t3: u64,
    q0: u64, q1: u64, q2: u64, q3: u64,
    qInvNeg: u64
) -> ((u64, u64, u64, u64), (u64, u64, u64, u64)) {
    let (u0, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y3), (0, 0)));
    let (c0, t0): (bool, u64) = jet::full_add_64(false, c1, t0);
    let (u1, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y2), (0, 0)));
    let (c0, t1): (bool, u64) = jet::full_add_64(c0, c1, t1);
    let (u2, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y1), (0, 0)));
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, c1, t2);
    let (u3, c1): (u64, u64) = <u128>::into(jet::full_multiply_64((x, y0), (0, 0)));
    let (c0, t3): (bool, u64) = jet::full_add_64(c0, c1, t3);

    let (_, c2): (bool, u64) = jet::full_add_64(c0, 0, 0);
    let (c0, t1): (bool, u64) = jet::full_add_64(false, u0, t1);
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, u1, t2);
    let (c0, t3): (bool, u64) = jet::full_add_64(c0, u2, t3);
    let (_, c2): (bool, u64) = jet::full_add_64(c0, u3, c2);

    (field_element_q_inv_mul(c2, q0, q1, q2, q3, t0, t1, t2, t3, qInvNeg))
}

// Note that the provided FieldElements should be already in montgomery format.
fn field_element_mul(x: FieldElement, y: FieldElement, modulus: FieldElement, qInvNeg: u64) -> FieldElement {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;
    let (q0, q1, q2, q3): (u64, u64, u64, u64) = modulus;

    // Process x3
    let (u0, t0): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y3), (0, 0)));
    let (u1, t1): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y2), (0, 0)));
    let (u2, t2): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y1), (0, 0)));
    let (u3, t3): (u64, u64) = <u128>::into(jet::full_multiply_64((x3, y0), (0, 0)));
    let (c0, t1): (bool, u64) = jet::full_add_64(false, u0, t1);
    let (c0, t2): (bool, u64) = jet::full_add_64(c0, u1, t2);
    let (c0, t3): (bool, u64) = jet::full_add_64(c0, u2, t3);
    let (_, c2): (bool, u64) = jet::full_add_64(c0, u3, 0);

    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_element_q_inv_mul(c2, q0, q1, q2, q3, t0, t1, t2, t3, qInvNeg);

    // Process x2
    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_element_process_x_mul(x2, y0, y1, y2, y3, t0, t1, t2, t3, q0, q1, q2, q3, qInvNeg);

    // Process x1
    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_element_process_x_mul(x1, y0, y1, y2, y3, t0, t1, t2, t3, q0, q1, q2, q3, qInvNeg);

    // Process x0
    let (
        (u0, u1, u2, u3), 
        (t0, t1, t2, t3)
    ): (
        (u64, u64, u64, u64), 
        (u64, u64, u64, u64)
    ) = field_element_process_x_mul(x0, y0, y1, y2, y3, t0, t1, t2, t3, q0, q1, q2, q3, qInvNeg);

    match field_element_smaller_then_modulus((t3, t2, t1, t0), modulus) {
        true => (t3, t2, t1, t0),
        false => {
            let (carry, s0): (bool, u64) = jet::full_subtract_64(false, t0, q3);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, t1, q2);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, t2, q1);
            let (carry, s3): (bool, u64) = jet::full_subtract_64(carry, t3, q0);
            (s3, s2, s1, s0)
        },
    }
}

fn field_element_to_mont(value: FieldElement, modulus: FieldElement, rSquare: FieldElement, qInvNeg: u64) -> FieldElement {
    field_element_mul(value, rSquare, modulus, qInvNeg)
}

fn field_element_from_mont_part(
    z0: u64, z1: u64, z2: u64, z3: u64,
    q0: u64, q1: u64, q2: u64, q3: u64,
    qInvNeg: u64
) -> (u64, u64, u64, u64) {
    let (_, m): (u64, u64) = <u128>::into(jet::full_multiply_64((qInvNeg, z0), (0, 0)));
    let (c, _): (u64, u64) = <u128>::into(jet::full_multiply_64((m, q3), (z0, 0)));
    let (c, z0): (u64, u64) = <u128>::into(jet::full_multiply_64((m, q2), (z1, c)));
    let (c, z1): (u64, u64) = <u128>::into(jet::full_multiply_64((m, q1), (z2, c)));
    let (c, z2): (u64, u64) = <u128>::into(jet::full_multiply_64((m, q0), (z3, c)));
    (c, z2, z1, z0)
}

// The following lines implement z = z * 1 with a modified CIOS 
// montgomery multiplication see Mul for algorithm documentation.
fn field_element_from_mont(value: FieldElement, modulus: FieldElement, qInvNeg: u64) -> FieldElement {
    let (z0, z1, z2, z3): (u64, u64, u64, u64) = value;
    let (q0, q1, q2, q3): (u64, u64, u64, u64) = modulus;

    let (z0, z1, z2, z3): (u64, u64, u64, u64) = field_element_from_mont_part(z3, z2, z1, z0, q0, q1, q2, q3, qInvNeg);
    let (z0, z1, z2, z3): (u64, u64, u64, u64) = field_element_from_mont_part(z3, z2, z1, z0, q0, q1, q2, q3, qInvNeg);
    let (z0, z1, z2, z3): (u64, u64, u64, u64) = field_element_from_mont_part(z3, z2, z1, z0, q0, q1, q2, q3, qInvNeg);
    let (z0, z1, z2, z3): (u64, u64, u64, u64) = field_element_from_mont_part(z3, z2, z1, z0, q0, q1, q2, q3, qInvNeg);

    match field_element_smaller_then_modulus((z0, z1, z2, z3), modulus) {
        true => (z0, z1, z2, z3),
        false => {
            let (carry, s0): (bool, u64) = jet::full_subtract_64(false, z0, q3);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, z1, q2);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, z2, q1);
            let (carry, s3): (bool, u64) = jet::full_subtract_64(carry, z3, q0);
            (s3, s2, s1, s0)
        },
    }
}

fn field_element_scalar_mul_bit_iterate(acc: (u64, FieldElement), ctx: (u64, FieldElement, FieldElement, u64), i: u8) -> Either<FieldElement, (u64, FieldElement)> {
    let (bitmask, total): (u64, FieldElement) = acc;
    
    match jet::eq_8(i, 64) {
        true => Left(total),
        false => {
            let (xi, a, modulus, qInvNeg): (u64, FieldElement, FieldElement, u64) = ctx;

            let total: FieldElement = field_element_mul(total, total, modulus, qInvNeg);
            let total: FieldElement = match jet::some_64(jet::and_64(xi, bitmask)) {
                true => field_element_mul(a, total, modulus, qInvNeg),
                false => total,
            };

            let bitmask: u64 =  jet::right_shift_64(1, bitmask);
            Right((bitmask, total))
        }
    }
}

// Same implementation as in G1
fn field_element_exp(a: FieldElement, x: FieldElement, one: FieldElement, modulus: FieldElement, qInvNeg :u64) -> FieldElement {
    // Most significant bit at the most left position
    let (x1, x2, x3, x4): (u64, u64, u64, u64) = field_element_from_mont(x, modulus, qInvNeg);

    // Moving MSB -> LSB

    let bitmask: u64 = 9223372036854775808; // 2^63
   
    let out: Either<FieldElement, (u64, FieldElement)> = for_while::<field_element_scalar_mul_bit_iterate>((bitmask, one), (x1, a, modulus, qInvNeg));
    let res: FieldElement = unwrap_left::<(u64, FieldElement)>(out);

    let out: Either<FieldElement, (u64, FieldElement)>  = for_while::<field_element_scalar_mul_bit_iterate>((bitmask, res), (x2, a, modulus, qInvNeg));
    let res: FieldElement = unwrap_left::<(u64, FieldElement)>(out);

    let out: Either<FieldElement, (u64, FieldElement)> = for_while::<field_element_scalar_mul_bit_iterate>((bitmask, res), (x3, a, modulus, qInvNeg));
    let res: FieldElement = unwrap_left::<(u64, FieldElement)>(out);

    let out: Either<FieldElement, (u64, FieldElement)> = for_while::<field_element_scalar_mul_bit_iterate>((bitmask, res), (x4, a, modulus, qInvNeg));
    let res: FieldElement = unwrap_left::<(u64, FieldElement)>(out);

    res
}

#ifdef TESTING

fn test_field_element_num_is_zero() {
    // Zero as parameter
    assert!(field_element_is_zero(field_element_new(0)));

    // One limb is not zero 
    let is_zero: bool = field_element_is_zero(field_element_new(18446744073709551616));
    assert!(<u1>::into(jet::complement_1(<bool>::into(is_zero))))
}

#endif
