#include "field.simf"

// q + r'.r = 1, i.e., qInvNeg = - q⁻¹ mod r
// used for Montgomery reduction
#define FP_Q_INV_NEG 9786893198990664585

// rSquare where r is the Montgommery constant
// see section 2.3.2 of Tolga Acar's thesis
// https://www.microsoft.com/en-us/research/wp-content/uploads/1998/06/97Acar.pdf
#define FP_R_SQUARE (493319470278259999, 5164255478447964150, 13107472804851548667, 17522657719365597833)

// Fp prime field modulus. 
//  - base 10: 21888242871839275222246405745257275088696311157297823662689037894645226208583
//  - base 16: 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD47
#define FP_MOD (3486998266802970665, 13281191951274694749, 10917124144477883021, 4332616871279656263)

fn fp_add(x: FieldElement, y: FieldElement) -> FieldElement {
    field_element_add(x, y, FP_MOD)
}

fn fp_double(x: FieldElement) -> FieldElement {
    field_element_double(x, FP_MOD)
}

fn fp_sub(x: FieldElement, y: FieldElement) -> FieldElement {
    field_element_sub(x, y, FP_MOD)
}

fn fp_neg(x: FieldElement) -> FieldElement {
    field_element_neg(x, FP_MOD)
}

fn fp_mul(x: FieldElement, y: FieldElement) -> FieldElement {
    field_element_mul(x, y, FP_MOD, FP_Q_INV_NEG)
}

fn fp_to_mont(x: FieldElement) -> FieldElement {
    field_element_to_mont(x, FP_MOD, FP_R_SQUARE, FP_Q_INV_NEG)
}

fn fp_new(value: u256) -> FieldElement {
    fp_to_mont(field_element_new(value))
}

fn fp_from_mont(x: FieldElement) -> FieldElement {
    field_element_from_mont(x, FP_MOD, FP_Q_INV_NEG)
}

fn fp_eq(x: FieldElement, y: FieldElement) -> bool {
    field_element_eq(x, y)
}

#ifdef TESTING

fn test_fp_add() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fp_new(200);
    let actual_1limb: FieldElement = fp_add(fp_new(100), fp_new(100));

    let _: u256 = dbg!(field_element_decompose(expected_1limb));
    let _: u256 = dbg!(field_element_decompose(actual_1limb));

    assert!(field_element_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fp_new(4567623456734502163058672543468019698188889198785079926);
    let actual_3limb: FieldElement = fp_add(
        fp_new(4567623456734423769034092193793479852479845689346389469), 
        fp_new(78394024580349674539845709043509438690457)
    );

    let _: u256 = dbg!(field_element_decompose(expected_3limb));
    let _: u256 = dbg!(field_element_decompose(actual_3limb));

    assert!(field_element_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: FieldElement = fp_new(100);
    let actual_overflow: FieldElement = fp_add(FP_MOD, fp_new(100));

    let _: u256 = dbg!(field_element_decompose(expected_overflow));
    let _: u256 = dbg!(field_element_decompose(actual_overflow));

    assert!(field_element_eq(expected_overflow, actual_overflow))   
}

fn test_fp_double() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fp_new(200);
    let actual_1limb: FieldElement = fp_double(fp_new(100));


    let _: u256 = dbg!(field_element_decompose(expected_1limb));
    let _: u256 = dbg!(field_element_decompose(actual_1limb));

    assert!(field_element_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fp_new(9135246913468847538068184387586959704959691378692778938);
    let actual_3limb: FieldElement = fp_double(fp_new(4567623456734423769034092193793479852479845689346389469));

    let _: u256 = dbg!(field_element_decompose(expected_3limb));
    let _: u256 = dbg!(field_element_decompose(actual_3limb));

    assert!(field_element_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: FieldElement = fp_new(21888242871839275222246405745257275088696311157297823662689037894645226208583);
    let actual_overflow: FieldElement = fp_double(fp_to_mont(FP_MOD));

    let _: u256 = dbg!(field_element_decompose(expected_overflow));
    let _: u256 = dbg!(field_element_decompose(actual_overflow));

    assert!(field_element_eq(expected_overflow, actual_overflow))
}

fn test_fp_sub() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fp_new(100);
    let actual_1limb: FieldElement = fp_sub(fp_new(200), fp_new(100));

    let _: u256 = dbg!(field_element_decompose(expected_1limb));
    let _: u256 = dbg!(field_element_decompose(actual_1limb));

    assert!(field_element_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fp_new(4567623456734345375009511844118940006770802179907699012);
    let actual_3limb: FieldElement = fp_sub(
        fp_new(4567623456734423769034092193793479852479845689346389469), 
        fp_new(78394024580349674539845709043509438690457)
    );

    let _: u256 = dbg!(field_element_decompose(expected_3limb));
    let _: u256 = dbg!(field_element_decompose(actual_3limb));

    assert!(field_element_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: FieldElement = fp_new(100);
    let actual_overflow: FieldElement = fp_sub(fp_new(100), FP_MOD);

    let _: u256 = dbg!(field_element_decompose(expected_overflow));
    let _: u256 = dbg!(field_element_decompose(actual_overflow));

    assert!(field_element_eq(expected_overflow, actual_overflow))   
}

fn test_fp_neg() {
    // Negate zero
    let expected_zero: FieldElement = fp_new(0);
    let actual_zero: FieldElement = fp_neg(fp_new(0));

    let _: u256 = dbg!(field_element_decompose(expected_zero));
    let _: u256 = dbg!(field_element_decompose(actual_zero));

    assert!(field_element_eq(actual_zero, expected_zero));

    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fp_new(21888242871839275222246405745257275088696311157297823662689037894645226208483);
    let actual_1limb: FieldElement = fp_neg(fp_new(100));

    let _: u256 = dbg!(field_element_decompose(expected_1limb));
    let _: u256 = dbg!(field_element_decompose(actual_1limb));

    assert!(field_element_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: FieldElement = fp_new(21888242871839275222241838121800540664927277065104030182836558048955879819114);
    let actual_3limb: FieldElement = fp_neg(fp_new(4567623456734423769034092193793479852479845689346389469));

    let _: u256 = dbg!(field_element_decompose(expected_3limb));
    let _: u256 = dbg!(field_element_decompose(actual_3limb));

    assert!(field_element_eq(expected_3limb, actual_3limb));
}

fn test_fp_mont() {
    // Only 1 limb is not zero
    let element1: u256 = 100;
    let expected_1limb: FieldElement = fp_new(element1);
    let actual_1limb: FieldElement = fp_from_mont(expected_1limb);

    let _: FieldElement = dbg!(expected_1limb);
    let _: FieldElement = dbg!(actual_1limb);

    assert!(field_element_eq(actual_1limb, field_element_new(element1)));

    // 4 limbs are not zero (FP_MOD-1 used)
    let expected_4limb: FieldElement = (3486998266802970665, 13281191951274694749, 10917124144477883021, 4332616871279656262);
    let actual_4limb: FieldElement = fp_from_mont(fp_to_mont(expected_4limb));

    let _: FieldElement = dbg!(expected_4limb);
    let _: FieldElement = dbg!(actual_4limb);

    assert!(field_element_eq(actual_4limb, expected_4limb));
}

fn test_fp_mul() {
    // Only 1 limb is not zero
    let expected_1limb: FieldElement = fp_new(10000);
    let actual_1limb: FieldElement = fp_mul(fp_new(100), fp_new(100));

    let _: u256 = dbg!(field_element_decompose(expected_1limb));
    let _: u256 = dbg!(field_element_decompose(actual_1limb));

    assert!(field_element_eq(actual_1limb, expected_1limb));

    // Two limbs are not zero and module overflow
    let expected_2limb: FieldElement = fp_new(4000000000000000000000);
    let actual_2limb: FieldElement = fp_mul(fp_new(2000000000000000000000), fp_new(2));

    let _: u256 = dbg!(field_element_decompose(expected_2limb));
    let _: u256 = dbg!(field_element_decompose(actual_2limb));

    assert!(field_element_eq(actual_2limb, expected_2limb));

    // All limbs are not zero
    let expected_4limb: FieldElement = fp_new(917110295551321618512897515040388707124899077868094579263219511374664388868);
    let actual_4limb: FieldElement = fp_mul(fp_new(123456789012345678901234567890123456789012345678901234567890), fp_new(123456789012345678901234567890123456789012345678901234567890));

    let _: u256 = dbg!(field_element_decompose(expected_2limb));
    let _: u256 = dbg!(field_element_decompose(actual_2limb));

    assert!(field_element_eq(actual_2limb, expected_2limb));
}


#endif
