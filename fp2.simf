#ifndef FP2_SIMF
#define FP2_SIMF

#include "fp.simf"

// Constants for power mul.
#define MUL_1_POWER_1_X (212598772761311868, 1278438861261381767, 14585784200204367754, 12653890742059813127)
#define MUL_1_POWER_1_Y (1200023580730561873, 15866167890766973222, 14992204589386555739, 11683091849979440498)
#define MUL_1_POWER_2_X (1825854335138010348, 8791150885551868305, 3782902503040509012, 13075984984163199792)
#define MUL_1_POWER_2_Y (2767831111890561987, 13179524609921305146, 12257807996192067905, 7963664994991228759)
#define MUL_1_POWER_3_X (2681173117283399901, 3578621962720924518, 13488546290961988299, 16482010305593259561)
#define MUL_1_POWER_3_Y (3208568454732775116, 7860678177968807019, 553939530661941723, 11661927080404088775)
#define MUL_1_POWER_4_X (1576150870752482284, 11282677263046157209, 11942187022798819835, 8314163329781907090)
#define MUL_1_POWER_4_Y (2630958277570195709, 4016233444936635065, 7118829427391486816, 6763840483288992073)
#define MUL_1_POWER_5_X (1345095164996126785, 3656613296917993960, 16303087968080972555, 14515217250696892391)
#define MUL_1_POWER_5_Y (3396254757538665050, 15253872307375509749, 367382125163301975, 957117326806663081)
#define MUL_2_POWER_1 (299787779797702374, 1017833795229664280, 17349508522658994025, 14595462726357228530)
#define MUL_2_POWER_2 (2775033306905974752, 6918009208039626314, 9065277094688085689, 3697675806616062876)
#define MUL_2_POWER_3 (2475245527108272378, 5900175412809962033, 10162512645738643279, 7548957153968385962)
#define MUL_2_POWER_4 (3187210487005268291, 12263358156045030468, 12014359695528440611, 8183898218631979349)
#define MUL_2_POWER_5 (711964959896995913, 6363182743235068435, 1851847049789797332, 634941064663593387)
#define MUL_3_POWER_1_X (581366264293887267, 7322192392869644725, 790120733010914719, 3914496794763385213)
#define MUL_3_POWER_1_Y (2767537931541304486, 11178533038884588256, 4440270538777280383, 12817045492518885689)
#define MUL_3_POWER_2_X (2316889217940299650, 1868623743233345524, 12903226530429559474, 14532872967180610477)
#define MUL_3_POWER_2_Y (740282956577754197, 7630813605053367399, 4121872836076202828, 12447993766991532972)
#define MUL_3_POWER_3_X (805825149519570764, 9702569988553770230, 15875321927225446337, 6297350639395948318)
#define MUL_3_POWER_3_Y (278429812070195549, 5420513773305887730, 10363184613815941297, 11117433864585119104)
#define MUL_3_POWER_4_X (481952561930628184, 15589480384090068090, 13823286637238282975, 4938922280314430175)
#define MUL_3_POWER_4_Y (1660844386505564338, 13057042392041828081, 11647802298615474591, 3105754162722846417)
#define MUL_3_POWER_5_X (1571199014989505406, 9239559758168096094, 13995139551301264911, 16193900971494954399)
#define MUL_3_POWER_5_Y (2657556514797346915, 10965492220518093659, 11171599147282597747, 3254114329011132839)

#define FP2_ZERO (FP_ZERO, FP_ZERO)
#define FP2_ONE (FP_ONE, FP_ZERO)

type Fp2 = (FieldElement, FieldElement);

// Creates a new Fp2 element from two 256-bit integers.
fn fp2_new(x: u256, y: u256) -> Fp2 {
    (fp_new(x), fp_new(y))
}

// Checks if an Fp2 element is zero.
fn fp2_is_zero(x: Fp2) -> bool {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let res: u1 = jet::and_1(<bool>::into(field_element_is_zero(x0)), <bool>::into(field_element_is_zero(x1)));
    <u1>::into(res)
}

// Adds two Fp2 elements component-wise modulo FP_MOD.
fn fp2_add(x: Fp2, y: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let (y0, y1): (FieldElement, FieldElement) = y;
    (fp_add(x0, y0), fp_add(x1, y1))
}

// Subtracts one Fp2 element from another component-wise modulo FP_MOD.
fn fp2_sub(x: Fp2, y: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let (y0, y1): (FieldElement, FieldElement) = y;
    (fp_sub(x0, y0), fp_sub(x1, y1))
}

// Doubles an Fp2 element component-wise.
fn fp2_double(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    (fp_double(x0), fp_double(x1))
}

// Negates an Fp2 element.
fn fp2_neg(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    (fp_neg(x0), fp_neg(x1))
}

// Computes the Fp2 conjugate.
fn fp2_conjugate(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    (x0, fp_neg(x1))
} 

// Checks equality of two Fp2 elements.
fn fp2_eq(x: Fp2, y: Fp2) -> bool {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let (y0, y1): (FieldElement, FieldElement) = y;
    let res: u1 = jet::and_1(<bool>::into(fp_eq(x0, y0)), <bool>::into(fp_eq(x1, y1)));
    <u1>::into(res)
}

// Multiplies two Fp2.
fn fp2_mul(x: Fp2, y: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let (y0, y1): (FieldElement, FieldElement) = y;

    let a: FieldElement = fp_add(x0, x1);
    let b: FieldElement = fp_add(y0, y1);
    let a: FieldElement = fp_mul(a, b);
    let b: FieldElement = fp_mul(x0, y0);
    let c: FieldElement = fp_mul(x1, y1);
    let z1: FieldElement = fp_sub(a, b);
    let z1: FieldElement = fp_sub(z1, c);
    let z0: FieldElement = fp_sub(b, c);

    (z0, z1)
}

// Squares an Fp2 element.
fn fp2_square(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let a: FieldElement = fp_add(x0, x1);
    let b: FieldElement = fp_sub(x0, x1);
    let a: FieldElement = fp_mul(a, b);
    let b: FieldElement = fp_mul(x0, x1);
    let b: FieldElement = fp_double(b);

    (a, b)
}

// Converts an Fp2 element to Montgomery form.
fn fp2_to_mont(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    (fp_to_mont(x0), fp_to_mont(x1))
}

// Converts an Fp2 element from Montgomery form.
fn fp2_from_mont(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    (fp_to_mont(x0), fp_to_mont(x1))
}

// Multiplies an Fp2 element by the quadratic nonresidue.
fn fp2_mul_by_non_residue(x: Fp2) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let p2: Fp2 = fp2_double(x);
    let p4: Fp2 = fp2_double(p2);
    let (p8_0, p8_1): (FieldElement, FieldElement) = fp2_double(p4);

    let c0: FieldElement = fp_add(p8_0, x0);
    let c0: FieldElement = fp_sub(c0, x1);
    let c1: FieldElement = fp_add(p8_1, x1);
    let c1: FieldElement = fp_add(c1, x0);

    (c0, c1)
}

// Multiplies both components of an Fp2 element by a base field element.
fn fp2_mul_by_b0(x: Fp2, y: FieldElement) -> Fp2 {
    let (x0, x1): (FieldElement, FieldElement) = x;
    let c0: FieldElement = fp_mul(x0, y);
    let c1: FieldElement = fp_mul(x1, y);

    (c0, c1)
}


fn mul_by_non_residue_1_power_1(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_1_POWER_1_X, MUL_1_POWER_1_Y))
}

fn mul_by_non_residue_1_power_2(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_1_POWER_2_X, MUL_1_POWER_2_Y))
}

fn mul_by_non_residue_1_power_3(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_1_POWER_3_X, MUL_1_POWER_3_Y))
}

fn mul_by_non_residue_1_power_4(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_1_POWER_4_X, MUL_1_POWER_4_Y))
}

fn mul_by_non_residue_1_power_5(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_1_POWER_5_X, MUL_1_POWER_5_Y))
}

fn mul_by_non_residue_2_power_1(x: Fp2) -> Fp2 {
    fp2_mul_by_b0(x, MUL_2_POWER_1)
}

fn mul_by_non_residue_2_power_2(x: Fp2) -> Fp2 {
    fp2_mul_by_b0(x, MUL_2_POWER_2)
}

fn mul_by_non_residue_2_power_3(x: Fp2) -> Fp2 {
    fp2_mul_by_b0(x, MUL_2_POWER_3)
}

fn mul_by_non_residue_2_power_4(x: Fp2) -> Fp2 {
    fp2_mul_by_b0(x, MUL_2_POWER_4)
}

fn mul_by_non_residue_2_power_5(x: Fp2) -> Fp2 {
    fp2_mul_by_b0(x, MUL_2_POWER_5)
}

fn mul_by_non_residue_3_power_1(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_3_POWER_1_X, MUL_3_POWER_1_Y))
}

fn mul_by_non_residue_3_power_2(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_3_POWER_2_X, MUL_3_POWER_2_Y))
}

fn mul_by_non_residue_3_power_3(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_3_POWER_3_X, MUL_3_POWER_3_Y))
}

fn mul_by_non_residue_3_power_4(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_3_POWER_4_X, MUL_3_POWER_4_Y))
}

fn mul_by_non_residue_3_power_5(x: Fp2) -> Fp2 {
    fp2_mul(x, (MUL_3_POWER_5_X, MUL_3_POWER_5_Y))
}

#ifdef TESTING

fn test_fp2_mul() {
    let a: Fp2 = fp2_new(1111, 2222);
    let b: Fp2 = fp2_new(3333, 4444);

    let res_expected: Fp2 = fp2_new(
        21888242871839275222246405745257275088696311157297823662689037894645220036978, 
        12343210
    );
    let res_actual: Fp2 = fp2_mul(a, b);

    assert!(fp2_eq(res_actual, res_expected))
}

fn test_fp2_mul_by_non_residue() {
    let a: Fp2 = fp2_new(1111, 2222);

    let res_expected: Fp2 = fp2_new(
        7777, 
        21109
    );
    let res_actual: Fp2 = fp2_mul_by_non_residue(a);

    assert!(fp2_eq(res_actual, res_expected))
}

fn test_fp2_square() {
    let a: Fp2 = fp2_new(1111, 2222);

    let res_expected: Fp2 = fp2_new(
        21888242871839275222246405745257275088696311157297823662689037894645222505620, 
        4937284
    );
    let res_actual: Fp2 = fp2_square(a);

    assert!(fp2_eq(res_actual, res_expected));
}

fn test_fp2_mul_by_non_residue_power_1() {
    let a: Fp2 = fp2_new(1111, 2222);

    let res_expected_1_pow_1: Fp2 = fp2_new(
        4559497168292011364399981374447775073050724677712451484847573096524203273729, 
        6132349745638277442981322309147597892108130981405985516937212133314116315898
    );
    let res_actual_1_pow_1: Fp2 = dbg!(mul_by_non_residue_1_power_1(a));

    assert!(fp2_eq(res_actual_1_pow_1, res_expected_1_pow_1));

    let res_expected_1_pow_2: Fp2 = fp2_new(
        16213698250348420146335131145897141268655903019739888224957220822432620869199, 
        9622665975770968019765568002009002323638882965381428690659689860497844891157
    );
    let res_actual_1_pow_2: Fp2 = mul_by_non_residue_1_power_2(a);

    assert!(fp2_eq(res_actual_1_pow_2, res_expected_1_pow_2));

    let res_expected_1_pow_3: Fp2 = fp2_new(
        6969796820417783188908347996280113650427890314499245644118733541000119674207, 
        8365568452576302184968954676087735337191548124322737325975547646791232098209
    );
    let res_actual_1_pow_3: Fp2 = mul_by_non_residue_1_power_3(a);

    assert!(fp2_eq(res_actual_1_pow_3, res_expected_1_pow_3));

    let res_expected_1_pow_4: Fp2 = fp2_new(
        1251268809105537867467443474864075136885977116317098422162299158329150820477, 
        2233584325203024485525019905410979888266325525940649018588045597794738232624
    );
    let res_actual_1_pow_4: Fp2 = mul_by_non_residue_1_power_4(a);

    assert!(fp2_eq(res_actual_1_pow_4, res_expected_1_pow_4));

    let res_expected_1_pow_5: Fp2 = fp2_new(
        5490234589715401166127518421302153934013764538649193058070439994764340447040, 
        6809586576560613804056842006247947969280955565988338894904992529842073402193
    );
    let res_actual_1_pow_5: Fp2 = mul_by_non_residue_1_power_5(a);

    assert!(fp2_eq(res_actual_1_pow_5, res_expected_1_pow_5));
}

fn test_fp2_mul_by_non_residue_power_2() {
    let a: Fp2 = fp2_new(1111, 2222);

    let res_expected_2_pow_1: Fp2 = fp2_new(
        21888242871839272773646306745693820392627552877876218360264781278736746874357, 
        21888242871839270325046207746130365696558794598454613057840524662828267540131
    );
    let res_actual_2_pow_1: Fp2 = mul_by_non_residue_2_power_1(a);

    assert!(fp2_eq(res_actual_2_pow_1, res_expected_2_pow_1));

    let res_expected_2_pow_2: Fp2 = fp2_new(
        21888242871839272773646306745693820392627552877876218360264781278736746873246, 
        21888242871839270325046207746130365696558794598454613057840524662828267537909
    );
    let res_actual_2_pow_2: Fp2 = mul_by_non_residue_2_power_2(a);

    assert!(fp2_eq(res_actual_2_pow_2, res_expected_2_pow_2));

    let res_expected_2_pow_3: Fp2 = fp2_new(
        21888242871839275222246405745257275088696311157297823662689037894645226207472, 
        21888242871839275222246405745257275088696311157297823662689037894645226206361
    );
    let res_actual_2_pow_3: Fp2 = mul_by_non_residue_2_power_3(a);

    assert!(fp2_eq(res_actual_2_pow_3, res_expected_2_pow_3));

    let res_expected_2_pow_4: Fp2 = fp2_new(
        2448600098999563454696068758279421605302424256615908479334226, 
        4897200197999126909392137516558843210604848513231816958668452
    );
    let res_actual_2_pow_4: Fp2 = mul_by_non_residue_2_power_4(a);

    assert!(fp2_eq(res_actual_2_pow_4, res_expected_2_pow_4));

    let res_expected_2_pow_5: Fp2 = fp2_new(
        2448600098999563454696068758279421605302424256615908479335337, 
        4897200197999126909392137516558843210604848513231816958670674
    );
    let res_actual_2_pow_5: Fp2 = mul_by_non_residue_2_power_5(a);

    assert!(fp2_eq(res_actual_2_pow_5, res_expected_2_pow_5));
}

fn test_fp2_mul_by_non_residue_power_3() {
    let a: Fp2 = fp2_new(1111, 2222);

    let res_expected_3_pow_1: Fp2 = fp2_new(
        19496111822120355905539961418991932882323234947216976518148270968875139421341,
        19581526286068249109422366553039633636353944074244265223492953057737209906763
    );
    let res_actual_3_pow_1: Fp2 = mul_by_non_residue_3_power_1(a);

    assert!(fp2_eq(res_actual_3_pow_1, res_expected_3_pow_1));

    let res_expected_3_pow_2: Fp2 = fp2_new(
        8954531159952645256765785760888457973132862803402506002642428329632448260387,
        9675091213243985182423541984319537464298742237200292333886953096120379629560
    );
    let res_actual_3_pow_2: Fp2 = mul_by_non_residue_3_power_2(a);

    assert!(fp2_eq(res_actual_3_pow_2, res_expected_3_pow_2));

    let res_expected_3_pow_3: Fp2 = fp2_new(
        14918446051421492033338057748977161438268420842798578018570304353645106534376,
        13522674419262973037277451069169539751504763032975086336713490247853994110374
    );
    let res_actual_3_pow_3: Fp2 = mul_by_non_residue_3_power_3(a);

    assert!(fp2_eq(res_actual_3_pow_3, res_expected_3_pow_3));

    let res_expected_3_pow_4: Fp2 = fp2_new(
        17541939573531507089392484944404716811558421546913130278472315341776739400248,
        5406076526330561362620760497647680279946693118299172135566969611476733963096
    );
    let res_actual_3_pow_4: Fp2 = mul_by_non_residue_3_power_4(a);

    assert!(fp2_eq(res_actual_3_pow_4, res_expected_3_pow_4));

    let res_expected_3_pow_5: Fp2 = fp2_new(
        7637072236804821702691632956093190178844679138923861031279389045416929546515,
        9213280698522159967655461017744222217776652791354113530218876592263695085153
    );
    let res_actual_3_pow_5: Fp2 = mul_by_non_residue_3_power_5(a);

    assert!(fp2_eq(res_actual_3_pow_5, res_expected_3_pow_5));
}

#endif
#endif
