#include "fp2.simf"

type Fp6 = (Fp2, Fp2, Fp2);

fn fp6_new(x: Fp2, y: Fp2, z: Fp2) -> Fp6 {
    (x, y, z)
}

fn fp6_add(x: Fp6, y: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    let (y0, y1, y2): (Fp2, Fp2, Fp2) = y;
    (fp2_add(x0, y0), fp2_add(x1, y1), fp2_add(x2, y2))
}

fn fp6_sub(x: Fp6, y: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    let (y0, y1, y2): (Fp2, Fp2, Fp2) = y;
    (fp2_sub(x0, y0), fp2_sub(x1, y1), fp2_sub(x2, y2))
}

fn fp6_double(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    (fp2_double(x0), fp2_double(x1), fp2_double(x2))
}

fn fp6_neg(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    (fp2_neg(x0), fp2_neg(x1), fp2_neg(x2))
}

fn fp6_conjugate(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    (x0, x1, fp2_neg(x2))
} 

fn fp6_eq(x: Fp6, y: Fp6) -> bool {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    let (y0, y1, y2): (Fp2, Fp2, Fp2) = y;

    let and_01: u1 = jet::and_1(
        <bool>::into(fp2_eq(x0, y0)),
        <bool>::into(fp2_eq(x1, y1))
    );

    let res: u1 = jet::and_1(
       and_01,
        <bool>::into(fp2_eq(x2, y2))
    );

    <u1>::into(res)
}

fn fp6_mul(x: Fp6, y: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;
    let (y0, y1, y2): (Fp2, Fp2, Fp2) = y;

    let a_a: Fp2 = fp2_mul(x0, y0);
    let b_b: Fp2 = fp2_mul(x1, y1);
    let c_c: Fp2 = fp2_mul(x2, y2);

    // Construct t1
    let t1: Fp2 = fp2_add(y1, y2);

    let tmp: Fp2 = fp2_add(x1, x2);
    let t1: Fp2 = fp2_mul(t1, tmp);
    let t1: Fp2 = fp2_sub(t1, b_b);
    let t1: Fp2 = fp2_sub(t1, c_c);
    let t1: Fp2 = fp2_mul_by_non_residue(t1);
    let t1: Fp2 = fp2_add(t1, a_a);

    // Construct t3
    let t3: Fp2 = fp2_add(y0, y2);

    let tmp: Fp2 = fp2_add(x0, x2);
    let t3: Fp2 = fp2_mul(t3, tmp);
    let t3: Fp2 = fp2_sub(t3, a_a);
    let t3: Fp2 = fp2_add(t3, b_b);
    let t3: Fp2 = fp2_sub(t3, c_c);

    // Construct t2
    let t2: Fp2 = fp2_add(y0, y1);

    let tmp: Fp2 = fp2_add(x0, x1);
    let t2: Fp2 = fp2_mul(t2, tmp);
    let t2: Fp2 = fp2_sub(t2, a_a);
    let t2: Fp2 = fp2_sub(t2, b_b);
    let tmp: Fp2 = fp2_mul_by_non_residue(c_c);
    let t2: Fp2 = fp2_add(t2, tmp);

    let _: Fp2 = dbg!(t2);

    (t1, t2, t3)
}

fn fp6_to_mont(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;

    (fp2_to_mont(x0), fp2_to_mont(x1), fp2_to_mont(x2))
}

fn fp6_from_mont(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;

    (fp2_from_mont(x0), fp2_from_mont(x1), fp2_from_mont(x2))
}

fn fp6_square(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;

    let c4: Fp2 = fp2_mul(x0, x1);
    let c4: Fp2 = fp2_double(c4);

    let c5: Fp2 = fp2_square(x2);

    let c1: Fp2 = fp2_mul_by_non_residue(c5);
    let c1: Fp2 = fp2_add(c1, c4);

    let c2: Fp2 = fp2_sub(c4, c5);
    let c3: Fp2 = fp2_square(x0);

    let c4: Fp2 = fp2_sub(x0, x1);
    let c4: Fp2 = fp2_add(c4, x2);

    let c5: Fp2 = fp2_mul(x1, x2);
    let c5: Fp2 = fp2_double(c5);

    let c4: Fp2 = fp2_square(c4);

    let c0: Fp2 = fp2_mul_by_non_residue(c5);
    let c0: Fp2 = fp2_add(c0, c3);
    
    let x2: Fp2 = fp2_add(c2, c4);
    let x2: Fp2 = fp2_add(x2, c5);
    let x2: Fp2 = fp2_sub(x2, c3);

    (c0, c1, x2)
}

fn fp6_mul_by_non_residue(x: Fp6) -> Fp6 {
    let (x0, x1, x2): (Fp2, Fp2, Fp2) = x;

    (fp2_mul_by_non_residue(x2), x0, x1)
}

#ifdef TESTING

fn test_fp6_mul() {
    let a: Fp6 = fp6_new(fp2_new(1111, 2222), fp2_new(3333, 4444), fp2_new(5555, 6666));
    let b: Fp6 = fp6_new(fp2_new(7777, 8888), fp2_new(9999, 0001), fp2_new(1111, 2222));

    let res_expected: Fp6 = fp6_new(
        fp2_new(
            354184578, 
            787540127
        ),
        fp2_new(
            21888242871839275222246405745257275088696311157297823662689037894645126226360, 
            255505558
        ),
        fp2_new(
            13573087, 
            150590495
        )
    );
    let res_actual: Fp6 = fp6_mul(a, b);

    assert!(fp6_eq(res_actual, res_expected))
}

fn test_fp6_square() {
    let a: Fp6 = fp6_new(fp2_new(1111, 2222), fp2_new(3333, 4444), fp2_new(5555, 6666));

    let res_expected: Fp6 = fp6_new(
        fp2_new(
            21888242871839275222246405745257275088696311157297823662689037894644928737222, 
            826995070
        ),
        fp2_new(
            21888242871839275222246405745257275088696311157297823662689037894645017608334, 
            677642229
        ),
        fp2_new(
            21888242871839275222246405745257275088696311157297823662689037894645200287842, 
            69121976
        )
    );
    let res_actual: Fp6 = fp6_square(a);

    assert!(fp6_eq(dbg!(res_actual), dbg!(res_expected)))
}

fn test_fp6_mul_by_non_residue() {
    let a: Fp6 = fp6_new(fp2_new(1111, 2222), fp2_new(3333, 4444), fp2_new(5555, 6666));

    let res_expected: Fp6 = fp6_new(
        fp2_new(
            43329, 
            65549
        ),
        fp2_new(
            1111, 
            2222
        ),
        fp2_new(
            3333, 
            4444
        )
    );
    let res_actual: Fp6 = fp6_mul_by_non_residue(a);

    let _: Fp6 = dbg!(res_expected);
    let _: Fp6 = dbg!(res_actual);

    assert!(fp6_eq(res_actual, res_expected))
}

#endif
