type Fr = (u64, u64, u64, u64);

// Creates new Fr from the provided u64 limbs tuple.
//
// Note, that the provided value must be less then the module.
fn fr_new(value: (u64, u64, u64, u64)) -> Fr {
    (value)
}

// Creates new Fr from the provided u256 value.
//
// Note, that the provided value must be less then the module.
fn fr_from_u256(value: u256) -> Fr {
    <u256>::into(value)
}

// Converts Fr (which is (u64, u64, u64, u64)) back to u256.
fn fr_to_u256(value: Fr) -> u256 {
    <Fr>::into(value)
}

// Returns constant 256-bit value for bn254 curve modulus.
//
// Modulus for bn254 curve is:
//  - base 10: 21888242871839275222246405745257275088696311157297823662689037894645226208583
//  - base 16: 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
fn fr_mod_u256() -> u256 {
    21888242871839275222246405745257275088696311157297823662689037894645226208583
}

// Returns constant 4 64-bit limbs for bn254 curve modulus, where the first one - least 
// significant limb.
fn fr_mod() -> Fr {
    <u256>::into(fr_mod_u256())
}

/// Returns true if the provided value is less then the bn254 modulus.
fn fr_smaller_then_modulus(value: Fr) -> bool {
    let (q0, q1, q2, q3): (u64, u64, u64, u64) = fr_mod();
    let (v0, v1, v2, v3): (u64, u64, u64, u64) = value;

    let v3_lt_q3: u1 = <bool>::into(jet::lt_64(v3, q3));
    let v2_eq_q2: u1 = <bool>::into(jet::eq_64(v2, q2));

    let v2_lt_q2: u1 = <bool>::into(jet::lt_64(v2, q2));
    let v1_eq_q1: u1 = <bool>::into(jet::eq_64(v1, q1));

    let v1_lt_q1: u1 = <bool>::into(jet::lt_64(v1, q1));
    let v0_eq_q0: u1 = <bool>::into(jet::eq_64(v0, q0));

    let v0_lt_q0: u1 = <bool>::into(jet::lt_64(v0, q0));

    let v2_and_v3: u1 = jet::and_1(v2_eq_q2, v3_lt_q3);
    let v2_or_v2: u1 = jet::or_1(v2_lt_q2, v2_and_v3);

    let v1_and_v2: u1 = jet::and_1(v1_eq_q1, v2_or_v2);
    let v1_or_v1: u1 = jet::or_1(v1_lt_q1, v1_and_v2);

    let v0_and_v1: u1 = jet::and_1(v0_eq_q0, v1_or_v1);
    let v0_or_v0: u1 = jet::or_1(v0_lt_q0, v0_and_v1);

    <u1>::into(v0_or_v0)
}

// Returns true if the provided value is zero.
fn fr_is_zero(x: Fr) -> bool {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, 0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, 0));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, 0));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, 0));

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}


// Returns the sum of provided x and y values taken by group modulus.
//
// y = (x + y) mod q
fn fr_add(x: Fr, y: Fr) -> Fr {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, y1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, y0);

    match fr_smaller_then_modulus((r0, r1, r2, r3)) {
        true => (r0, r1, r2, r3),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r0, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r0, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Returns the double of provided x value taken by group modulus.
//
// y = (x + x) mod q
fn fr_double(x: Fr) -> Fr {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, x3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, x2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, x1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, x0);

    match fr_smaller_then_modulus((r0, r1, r2, r3)) {
        true => (r0, r1, r2, r3),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Returns the subtraction of provided x and y values taken by group modulus.
//
// y = (x - y) mod q
fn fr_sub(x: Fr, y: Fr) -> Fr {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let (carry, r3): (bool, u64) = jet::full_subtract_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_subtract_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_subtract_64(carry, x1, y1);
    let (carry, r0): (bool, u64) = jet::full_subtract_64(carry, x0, y0);

    match carry {
        false => (r0, r1, r2, r3),
        true => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_add_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_add_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_add_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_add_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Takes negation of the provided value by subtracting the value from the group modulus.
//
// y = q - x
fn fr_neg(x: Fr) -> Fr {
    match fr_is_zero(x) {
        true => x,
        false => {
            let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, m3, x3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, m2, x2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, m1, x1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, m0, x0);

            (s0, s1, s2, s3)
        }
    }
}