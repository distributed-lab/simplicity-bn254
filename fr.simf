type Fr = (u64, u64, u64, u64);

// Creates new Fr from the provided u64 limbs tuple.
//
// Note, that the provided value must be less then the module.
fn fr_new(value: (u64, u64, u64, u64)) -> Fr {
    (value)
}

// Creates new Fr from the provided u256 value.
//
// Note, that the provided value must be less then the module.
fn fr_from_u256(value: u256) -> Fr {
    <u256>::into(value)
}

// Converts Fr (which is (u64, u64, u64, u64)) back to u256.
fn fr_to_u256(value: Fr) -> u256 {
    <Fr>::into(value)
}

// Returns constant 256-bit value for bn254 curve modulus.
//
// Modulus for bn254 curve is:
//  - base 10: 21888242871839275222246405745257275088696311157297823662689037894645226208583
//  - base 16: 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47
fn fr_mod_u256() -> u256 {
    21888242871839275222246405745257275088696311157297823662689037894645226208583
}

// Returns constant 4 64-bit limbs for bn254 curve modulus, where the first one - least 
// significant limb.
fn fr_mod() -> Fr {
    <u256>::into(fr_mod_u256())
}

/// Returns true if the provided value is less then the bn254 modulus.
fn fr_smaller_then_modulus(value: Fr) -> bool {
    let (q0, q1, q2, q3): (u64, u64, u64, u64) = fr_mod();
    let (v0, v1, v2, v3): (u64, u64, u64, u64) = value;

    let v3_lt_q3: u1 = <bool>::into(jet::lt_64(v3, q3));
    let v2_eq_q2: u1 = <bool>::into(jet::eq_64(v2, q2));

    let v2_lt_q2: u1 = <bool>::into(jet::lt_64(v2, q2));
    let v1_eq_q1: u1 = <bool>::into(jet::eq_64(v1, q1));

    let v1_lt_q1: u1 = <bool>::into(jet::lt_64(v1, q1));
    let v0_eq_q0: u1 = <bool>::into(jet::eq_64(v0, q0));

    let v0_lt_q0: u1 = <bool>::into(jet::lt_64(v0, q0));

    let v2_and_v3: u1 = jet::and_1(v2_eq_q2, v3_lt_q3);
    let v2_or_v2: u1 = jet::or_1(v2_lt_q2, v2_and_v3);

    let v1_and_v2: u1 = jet::and_1(v1_eq_q1, v2_or_v2);
    let v1_or_v1: u1 = jet::or_1(v1_lt_q1, v1_and_v2);

    let v0_and_v1: u1 = jet::and_1(v0_eq_q0, v1_or_v1);
    let v0_or_v0: u1 = jet::or_1(v0_lt_q0, v0_and_v1);

    <u1>::into(v0_or_v0)
}

// Returns true if the provided value is zero.
fn fr_is_zero(x: Fr) -> bool {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, 0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, 0));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, 0));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, 0));

    let _: u64 = dbg!(x0);
    let _: u64 = dbg!(x1);
    let _: u64 = dbg!(x2);
    let _: u64 = dbg!(x3);

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}

// Returns true if value x is equal to value y.
fn fr_eq(x: Fr, y: Fr) -> bool {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let x0_eq: u1 = <bool>::into(jet::eq_64(x0, y0));
    let x1_eq: u1 = <bool>::into(jet::eq_64(x1, y1));
    let x2_eq: u1 = <bool>::into(jet::eq_64(x2, y2));
    let x3_eq: u1 = <bool>::into(jet::eq_64(x3, y3));

    let res: u1 = jet::and_1(jet::and_1(x0_eq, x1_eq), jet::and_1(x2_eq, x3_eq));
    <u1>::into(res)
}

// Returns the sum of provided x and y values taken by group modulus.
//
// y = (x + y) mod q
fn fr_add(x: Fr, y: Fr) -> Fr {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, y1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, y0);

    match fr_smaller_then_modulus((r0, r1, r2, r3)) {
        true => (r0, r1, r2, r3),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Returns the double of provided x value taken by group modulus.
//
// y = (x + x) mod q
fn fr_double(x: Fr) -> Fr {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

    let (carry, r3): (bool, u64) = jet::full_add_64(false, x3, x3);
    let (carry, r2): (bool, u64) = jet::full_add_64(carry, x2, x2);
    let (carry, r1): (bool, u64) = jet::full_add_64(carry, x1, x1);
    let (_, r0): (bool, u64) = jet::full_add_64(carry, x0, x0);

    match fr_smaller_then_modulus((r0, r1, r2, r3)) {
        true => (r0, r1, r2, r3),
        false => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Returns the subtraction of provided x and y values taken by group modulus.
//
// y = (x - y) mod q
fn fr_sub(x: Fr, y: Fr) -> Fr {
    let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;
    let (y0, y1, y2, y3): (u64, u64, u64, u64) = y;

    let (carry, r3): (bool, u64) = jet::full_subtract_64(false, x3, y3);
    let (carry, r2): (bool, u64) = jet::full_subtract_64(carry, x2, y2);
    let (carry, r1): (bool, u64) = jet::full_subtract_64(carry, x1, y1);
    let (carry, r0): (bool, u64) = jet::full_subtract_64(carry, x0, y0);

    match carry {
        false => (r0, r1, r2, r3),
        true => {
            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_add_64(false, r3, m3);
            let (carry, s2): (bool, u64) = jet::full_add_64(carry, r2, m2);
            let (carry, s1): (bool, u64) = jet::full_add_64(carry, r1, m1);
            let (_, s0): (bool, u64) = jet::full_add_64(carry, r0, m0);

            (s0, s1, s2, s3)
        },
    }
}

// Takes negation of the provided value by subtracting the value from the group modulus.
//
// y = q - x
fn fr_neg(x: Fr) -> Fr {
    match fr_is_zero(x) {
        true => x,
        false => {
            let (x0, x1, x2, x3): (u64, u64, u64, u64) = x;

            let (m0, m1, m2, m3): (u64, u64, u64, u64) = fr_mod();
            let (carry, s3): (bool, u64) = jet::full_subtract_64(false, m3, x3);
            let (carry, s2): (bool, u64) = jet::full_subtract_64(carry, m2, x2);
            let (carry, s1): (bool, u64) = jet::full_subtract_64(carry, m1, x1);
            let (_, s0): (bool, u64) = jet::full_subtract_64(carry, m0, x0);

            (s0, s1, s2, s3)
        }
    }
}

#ifdef TESTING

fn test_fr_eq() {
    let a: Fr = fr_mod();
    let b: Fr = fr_mod();
    assert!(fr_eq(a, b))   
}

fn test_fr_add_mod() {
    // Only 1 limb is not zero
    let expected_1limb: Fr = fr_from_u256(200);
    let actual_1limb: Fr = fr_add(fr_from_u256(100), fr_from_u256(100));

    let _: u256 = dbg!(fr_to_u256(expected_1limb));
    let _: u256 = dbg!(fr_to_u256(actual_1limb));

    assert!(fr_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: Fr = fr_from_u256(4567623456734502163058672543468019698188889198785079926);
    let actual_3limb: Fr = fr_add(
        fr_from_u256(4567623456734423769034092193793479852479845689346389469), 
        fr_from_u256(78394024580349674539845709043509438690457)
    );

    let _: u256 = dbg!(fr_to_u256(expected_3limb));
    let _: u256 = dbg!(fr_to_u256(actual_3limb));

    assert!(fr_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: Fr = fr_from_u256(100);
    let actual_overflow: Fr = fr_add(fr_mod(), fr_from_u256(100));

    let _: u256 = dbg!(fr_to_u256(expected_overflow));
    let _: u256 = dbg!(fr_to_u256(actual_overflow));

    assert!(fr_eq(expected_overflow, actual_overflow))   
}

fn test_fr_double_mod() {
    // Only 1 limb is not zero
    let expected_1limb: Fr = fr_from_u256(200);
    let actual_1limb: Fr = fr_double(fr_from_u256(100));

    let _: u256 = dbg!(fr_to_u256(expected_1limb));
    let _: u256 = dbg!(fr_to_u256(actual_1limb));

    assert!(fr_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: Fr = fr_from_u256(9135246913468847538068184387586959704959691378692778938);
    let actual_3limb: Fr = fr_double(fr_from_u256(4567623456734423769034092193793479852479845689346389469));

    let _: u256 = dbg!(fr_to_u256(expected_3limb));
    let _: u256 = dbg!(fr_to_u256(actual_3limb));

    assert!(fr_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: Fr = fr_from_u256(21888242871839275222246405745257275088696311157297823662689037894645226208583);
    let actual_overflow: Fr = fr_double(fr_mod());

    let _: u256 = dbg!(fr_to_u256(expected_overflow));
    let _: u256 = dbg!(fr_to_u256(actual_overflow));

    assert!(fr_eq(expected_overflow, actual_overflow))   
}


fn test_fr_sub_mod() {
    // Only 1 limb is not zero
    let expected_1limb: Fr = fr_from_u256(100);
    let actual_1limb: Fr = fr_sub(fr_from_u256(200), fr_from_u256(100));

    let _: u256 = dbg!(fr_to_u256(expected_1limb));
    let _: u256 = dbg!(fr_to_u256(actual_1limb));

    assert!(fr_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: Fr = fr_from_u256(4567623456734345375009511844118940006770802179907699012);
    let actual_3limb: Fr = fr_sub(
        fr_from_u256(4567623456734423769034092193793479852479845689346389469), 
        fr_from_u256(78394024580349674539845709043509438690457)
    );

    let _: u256 = dbg!(fr_to_u256(expected_3limb));
    let _: u256 = dbg!(fr_to_u256(actual_3limb));

    assert!(fr_eq(expected_3limb, actual_3limb));

    // Module overflow
    let expected_overflow: Fr = fr_from_u256(100);
    let actual_overflow: Fr = fr_sub(fr_from_u256(100), fr_mod());

    let _: u256 = dbg!(fr_to_u256(expected_overflow));
    let _: u256 = dbg!(fr_to_u256(actual_overflow));

    assert!(fr_eq(expected_overflow, actual_overflow))   
}

fn test_fr_is_zero() {
    // Zero as parameter
    assert!(fr_is_zero(fr_from_u256(0)));

    // One limb is not zero 
    let is_zero: bool = fr_is_zero(fr_from_u256(18446744073709551616));
    assert!(<u1>::into(jet::complement_1(<bool>::into(is_zero))))
}

fn test_fr_neg() {
    // Negate zero
    let expected_zero: Fr = fr_from_u256(0);
    let actual_zero: Fr = fr_neg(fr_from_u256(0));

    let _: u256 = dbg!(fr_to_u256(expected_zero));
    let _: u256 = dbg!(fr_to_u256(actual_zero));

    assert!(fr_eq(actual_zero, expected_zero));

    // Only 1 limb is not zero
    let expected_1limb: Fr = fr_from_u256(21888242871839275222246405745257275088696311157297823662689037894645226208483);
    let actual_1limb: Fr = fr_neg(fr_from_u256(100));

    let _: u256 = dbg!(fr_to_u256(expected_1limb));
    let _: u256 = dbg!(fr_to_u256(actual_1limb));

    assert!(fr_eq(actual_1limb, expected_1limb));

    // 3 limbs are not zero
    let expected_3limb: Fr = fr_from_u256(21888242871839275222241838121800540664927277065104030182836558048955879819114);
    let actual_3limb: Fr = fr_neg(fr_from_u256(4567623456734423769034092193793479852479845689346389469));

    let _: u256 = dbg!(fr_to_u256(expected_3limb));
    let _: u256 = dbg!(fr_to_u256(actual_3limb));

    assert!(fr_eq(expected_3limb, actual_3limb));
}

#endif