#include "fr.simf"

type G1 = (FieldElement, FieldElement, FieldElement);

fn g1_zero() -> G1 {
    (FP_ZERO, FP_ZERO, FP_ZERO)
}

fn g1_is_zero(a: G1) -> bool {
    let (ax, ay, az): (FieldElement, FieldElement, FieldElement) = a;
    field_element_is_zero(az)
}

// Returns true if value point a is equal to point b in Jacobian coordinates.
fn g1_eq(a: G1, b: G1) -> bool {
    let (ax, ay, az): (FieldElement, FieldElement, FieldElement) = a;
    let (bx, by, bz): (FieldElement, FieldElement, FieldElement) = b;


    let az_is_zero: u1 = <bool>::into(field_element_is_zero(az));
    let bz_is_zero: u1 = <bool>::into(field_element_is_zero(bz));

    match <u1>::into(jet::and_1(jet::complement_1(az_is_zero), jet::complement_1(bz_is_zero))) {
        true => {
            let az2: FieldElement = fp_square(az);
            let az3: FieldElement = fp_mul(az2, az);

            let bz2: FieldElement = fp_square(bz);
            let bz3: FieldElement = fp_mul(bz2, bz);

            let eql: u1 = <bool>::into(fp_eq(fp_mul(ax, bz2), fp_mul(bx, az2)));
            let eqr: u1 = <bool>::into(fp_eq(fp_mul(ay, bz3), fp_mul(by, az3)));

            <u1>::into(jet::and_1(eql, eqr))
        },
        false => {
             <u1>::into(jet::and_1(az_is_zero, bz_is_zero))
        },
    }
}

fn g1_negate(a: G1) -> G1 {
    let (ax, ay, az): (FieldElement, FieldElement, FieldElement) = a;
    (ax, fp_neg(ay), az)
}


// Following gnark-crypto which itself follows
// https://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
fn g1_double(a: G1) -> G1 {
    let (ax, ay, az): (FieldElement, FieldElement, FieldElement) = a;

    let A: FieldElement = fp_square(ax);
    let B: FieldElement = fp_square(ay);
    let C: FieldElement = fp_square(B);
    let D: FieldElement = fp_double(fp_sub(fp_sub(fp_square(fp_add(ax, B)), A), C));

    let E: FieldElement = fp_add(fp_double(A), A);
    let F: FieldElement = fp_square(E);
    let t: FieldElement = fp_double(D);

    let bz: FieldElement = fp_double(fp_mul(ay, az));

    let bx: FieldElement = fp_sub(F, t);

    let by: FieldElement = fp_mul(fp_sub(D, bx), E);
    let by: FieldElement = fp_sub(by, fp_double(fp_double(fp_double(C))));

    (bx, by, bz)
}

// Following gnark-crypto which itself follows
// https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl
fn g1_add(q: G1, p: G1) -> G1 {
    // TODO do we need to check the zero equality?

    let (qx, qy, qz): (FieldElement, FieldElement, FieldElement) = q;
    let (px, py, pz): (FieldElement, FieldElement, FieldElement) = p;

    let Z1Z1: FieldElement = fp_square(qz);
    let Z2Z2: FieldElement = fp_square(pz);
    let U1: FieldElement = fp_mul(qx, Z2Z2);
    let U2: FieldElement = fp_mul(px, Z1Z1);
    let S1: FieldElement = fp_mul(fp_mul(qy, pz), Z2Z2);
    let S2: FieldElement = fp_mul(fp_mul(py, qz), Z1Z1);


    // TODO: Check if we really need this.
    // Probably, while we do not care about the speed, 
    // such conditional execution will only increase the program size.
    // match jet::and_1(fp_eq(U1, U2), fp_eq(S1, S2)) {
    //     true => g1_double(p),
    //     false => {
            
    //     }
    // }

    let H: FieldElement = fp_sub(U2, U1);
    let I: FieldElement = fp_square(fp_double(H));
    let J: FieldElement = fp_mul(H, I);
    let r: FieldElement = fp_double(fp_sub(S2, S1));
    let V: FieldElement = fp_mul(U1, I);

    let rx: FieldElement = fp_sub(fp_sub(fp_sub(fp_square(r), J), V), V);

    let ry: FieldElement = fp_mul(fp_sub(V, rx), r);
    let S1: FieldElement = fp_double(fp_mul(S1, J));
    let ry: FieldElement = fp_sub(ry, S1);

    let rz: FieldElement = fp_mul(fp_sub(fp_sub(fp_square(fp_add(pz, qz)), Z1Z1), Z2Z2), H);

    (rx, ry, rz)
}

fn g1_sub(a: G1, b: G1) -> G1 {
    g1_add(a, g1_negate(b))
}

fn g1_scalar_mul_bit_iterate(bit: u1, ctx: (G1, G1)) -> (G1, G1) {
    let (sum, p): (G1, G1) = ctx;
    let sum: G1 = g1_double(sum);
    match <u1>::into(bit) {
        true => {
            (sum, p)
        },
        false => {
            (g1_add(sum, p), p)
        }
    }
}

// Multiply point by scalar. Uses fast exponention idea. 
// It is sssumed that scalar is in the Montgomery form.
fn g1_scalar_mul(p: G1, s: FieldElement) -> G1 {
    // Most significant bit at the most left position
    let (s1, s2, s3, s4): (u64, u64, u64, u64) = fr_from_mont(s);

    // Moving MSB -> LSB

    let s1bits: [u1; 64] = <u64>::into(s1);
    let (res, _): (G1, G1) = array_fold::<g1_scalar_mul_bit_iterate, 64>(s1bits, (g1_zero(), p));

    let s2bits: [u1; 64] = <u64>::into(s2);
    let (res, _): (G1, G1) = array_fold::<g1_scalar_mul_bit_iterate, 64>(s2bits, (res, p));

    let s3bits: [u1; 64] = <u64>::into(s3);
    let (res, _): (G1, G1) = array_fold::<g1_scalar_mul_bit_iterate, 64>(s3bits, (res, p));

    let s4bits: [u1; 64] = <u64>::into(s4);
    let (res, _): (G1, G1) = array_fold::<g1_scalar_mul_bit_iterate, 64>(s4bits, (res, p));
    
    res
}

#ifdef TESTING

fn test_g1_equal() {
    let ax: FieldElement = (2660290123357522574, 7623207791470518540, 5314868706973180553, 10722157497460808825);
    let ay: FieldElement = (2482923816546699733, 4903284613741271418, 16471778726647404852, 16098156220303574542);
    let az: FieldElement = (2848318405948801671, 6136696105659101695, 3335757777677701823, 15528660411355722902);

    let bx: FieldElement = (2660290123357522574, 7623207791470518540, 5314868706973180553, 10722157497460808825);
    let by: FieldElement = (2482923816546699733, 4903284613741271418, 16471778726647404852, 16098156220303574542);
    let bz: FieldElement = (2848318405948801671, 6136696105659101695, 3335757777677701823, 15528660411355722902);

    let a: G1 = (ax,ay,az);
    let b: G1 = (bx,by,bz);

    assert!(g1_eq(a,b));

    let cx: FieldElement = (1799272946717626621, 4692510101642634287, 7744477234110802071, 9226155861685280021);
    let cy: FieldElement = (1749827502192827435, 14295353047236301223, 12522662654711884246, 8278769098901179243);
    let cz: FieldElement = (1016462830313374142, 7942765140776706759, 3726500310570118390, 3359969918945609066);

    let c: G1 = (cx,cy,cz);
    
    assert!(<u1>::into(jet::complement_1(<bool>::into(g1_eq(a,c)))))
}

fn test_g1_negate() {
    let ax: FieldElement = (2660290123357522574, 7623207791470518540, 5314868706973180553, 10722157497460808825);
    let ay: FieldElement = (2482923816546699733, 4903284613741271418, 16471778726647404852, 16098156220303574542);
    let az: FieldElement = (2848318405948801671, 6136696105659101695, 3335757777677701823, 15528660411355722902);

    let bx: FieldElement = (2660290123357522574, 7623207791470518540, 5314868706973180553, 10722157497460808825);
    let by: FieldElement = (1004074450256270932, 8377907337533423330, 12892089491540029784, 6681204724685633337);
    let bz: FieldElement = (2848318405948801671, 6136696105659101695, 3335757777677701823, 15528660411355722902);

    let a: G1 = (ax,ay,az);
    let b: G1 = (bx,by,bz);

    assert!(g1_eq(b,g1_negate(a)))
}

fn test_g1_double() {
    let ax: FieldElement = (2660290123357522574, 7623207791470518540, 5314868706973180553, 10722157497460808825);
    let ay: FieldElement = (2482923816546699733, 4903284613741271418, 16471778726647404852, 16098156220303574542);
    let az: FieldElement = (2848318405948801671, 6136696105659101695, 3335757777677701823, 15528660411355722902);

    let bx: FieldElement = (2579478271892018428, 16740039199248248983, 11314098184430500312, 15560659807810893111);
    let by: FieldElement = (86907429614594559, 3073471434231216203, 12032880197668961362, 431213066858707297);
    let bz: FieldElement = (2892882494169863239, 13303912991492853687, 6533256836492562485, 8436369679768058000);

    let a: G1 = (ax,ay,az);
    let b: G1 = (bx,by,bz);

    assert!(g1_eq(b,g1_double(a)))
}

#endif
