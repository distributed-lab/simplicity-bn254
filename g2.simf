#ifndef G2_SIMF
#define G2_SIMF

#include "fr.simf"
#include "fp2.simf"

#define G2_ZERO (FP2_ZERO, FP2_ZERO, FP2_ZERO)

type G2 = (Fp2, Fp2, Fp2);

fn g2_is_zero(a: G2) -> bool {
    let (ax, ay, az): (Fp2, Fp2, Fp2) = a;
    fp2_is_zero(az)
}

fn g2_eq(a: G2, b: G2) -> bool {
    let (ax, ay, az): (Fp2, Fp2, Fp2) = a;
    let (bx, by, bz): (Fp2, Fp2, Fp2) = b;

    let az_is_zero: u1 = <bool>::into(fp2_is_zero(az));
    let bz_is_zero: u1 = <bool>::into(fp2_is_zero(bz));

    match <u1>::into(jet::and_1(jet::complement_1(az_is_zero), jet::complement_1(bz_is_zero))) {
        true => {
            let az2: Fp2 = fp2_square(az);
            let az3: Fp2 = fp2_mul(az2, az);

            let bz2: Fp2 = fp2_square(bz);
            let bz3: Fp2 = fp2_mul(bz2, bz);

            let eql: u1 = <bool>::into(fp2_eq(fp2_mul(ax, bz2), fp2_mul(bx, az2)));
            let eqr: u1 = <bool>::into(fp2_eq(fp2_mul(ay, bz3), fp2_mul(by, az3)));

            <u1>::into(jet::and_1(eql, eqr))
        },
        false => {
             <u1>::into(jet::and_1(az_is_zero, bz_is_zero))
        },
    }
}

fn g2_negate(a: G2) -> G2 {
    let (ax, ay, az): (Fp2, Fp2, Fp2) = a;
    (ax, fp2_neg(ay), az)
}

// Following gnark-crypto which itself follows
// https://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
fn g2_double(a: G2) -> G2 {
    let (ax, ay, az): (Fp2, Fp2, Fp2) = a;

    let A: Fp2 = fp2_square(ax);
    let B: Fp2 = fp2_square(ay);
    let C: Fp2 = fp2_square(B);
    let D: Fp2 = fp2_double(fp2_sub(fp2_sub(fp2_square(fp2_add(ax, B)), A), C));

    let E: Fp2 = fp2_add(fp2_double(A), A);
    let F: Fp2 = fp2_square(E);
    let t: Fp2 = fp2_double(D);

    let bz: Fp2 = fp2_double(fp2_mul(ay, az));

    let bx: Fp2 = fp2_sub(F, t);

    let by: Fp2 = fp2_mul(fp2_sub(D, bx), E);
    let by: Fp2 = fp2_sub(by, fp2_double(fp2_double(fp2_double(C))));

    (bx, by, bz)
}

// This is an auxiliary function provided to perform add operation over G1.
fn g2_add_main_operations(q: G2, p: G2) -> G2 {
    let (qx, qy, qz): (Fp2, Fp2, Fp2) = q;
    let (px, py, pz): (Fp2, Fp2, Fp2) = p;

    let Z1Z1: Fp2 = fp2_square(qz);
    let Z2Z2: Fp2 = fp2_square(pz);
    let U1: Fp2 = fp2_mul(qx, Z2Z2);
    let U2: Fp2 = fp2_mul(px, Z1Z1);
    let S1: Fp2 = fp2_mul(fp2_mul(qy, pz), Z2Z2);
    let S2: Fp2 = fp2_mul(fp2_mul(py, qz), Z1Z1);

    let u_and_s: bool = <u1>::into(jet::and_1(<bool>::into(fp2_eq(U1, U2)), <bool>::into(fp2_eq(S1, S2))));
    match u_and_s {
        true => g2_double(q),
        false => {
            // TODO: Check if we really need this.
            // Probably, while we do not care about the speed, 
            // such conditional execution will only increase the program size.
            // match jet::and_1(fp2_eq(U1, U2), fp2_eq(S1, S2)) {
            //     true => g2_double(p),
            //     false => {
                    
            //     }
            // }

            let H: Fp2 = fp2_sub(U2, U1);
            let I: Fp2 = fp2_square(fp2_double(H));
            let J: Fp2 = fp2_mul(H, I);
            let r: Fp2 = fp2_double(fp2_sub(S2, S1));
            let V: Fp2 = fp2_mul(U1, I);

            let rx: Fp2 = fp2_sub(fp2_sub(fp2_sub(fp2_square(r), J), V), V);

            let ry: Fp2 = fp2_mul(fp2_sub(V, rx), r);
            let S1: Fp2 = fp2_double(fp2_mul(S1, J));
            let ry: Fp2 = fp2_sub(ry, S1);

            let rz: Fp2 = fp2_mul(fp2_sub(fp2_sub(fp2_square(fp2_add(pz, qz)), Z1Z1), Z2Z2), H);
            (rx, ry, rz)
        }
    }
}

// Following gnark-crypto which itself follows
// https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl
fn g2_add(q: G2, p: G2) -> G2 {
    // Check one was zero -> the result is zero.
    let p_is_zero_bool: bool = g2_is_zero(p);
    let p_is_zero: u1 = <bool>::into(p_is_zero_bool);
    let q_is_zero: u1 = <bool>::into(g2_is_zero(q));
    let check_bit: u1 = jet::xor_1(p_is_zero, q_is_zero);

    match jet::some_1(check_bit) {
        true => match g2_is_zero(p) {
                true => q,
                false => p,
            },
        false => g2_add_main_operations(q, p),
    }
}

fn g2_sub(a: G2, b: G2) -> G2 {
    g2_add(a, g2_negate(b))
}

fn g2_scalar_mul_bit_iterate(acc: (u64, G2), ctx: (u64, G2), i: u8) -> Either<G2, (u64, G2)> {
    let (bitmask, sum): (u64, G2) = acc;
    
    match jet::eq_8(i, 64) {
        true => Left(sum),
        false => {
            let (value, p): (u64, G2) = ctx;

            let sum: G2 = g2_double(sum);
            let sum: G2 = match jet::some_64(jet::and_64(value, bitmask)) {
                true => g2_add(p, sum),
                false => sum,
            };

            let bitmask: u64 =  jet::right_shift_64(1, bitmask);
            Right((bitmask, sum))
        }
    }
}

// TODO: Use after array_fold will be fixed
// fn g2_scalar_mul_bit_iterate(bit: u1, ctx: (G2, G2)) -> (G2, G2) {
//     let (sum, p): (G2, G2) = ctx;
//     let sum: G2 = g2_double(sum);
//     match <u1>::into(bit) {
//         true => {
//             (sum, p)
//         },
//         false => {
//             (g2_add(sum, p), p)
//         }
//     }
// }

// Multiply point by scalar. Uses fast exponention idea. 
// It is sssumed that scalar is in the Montgomery form.
fn g2_scalar_mul(p: G2, s: FieldElement) -> G2 {
    // Most significant bit at the most left position
    let (s1, s2, s3, s4): (u64, u64, u64, u64) = fr_from_mont(s);

    // Moving MSB -> LSB

    let bitmask: u64 = 9223372036854775808; // 2^63
   
    let out: Either<G2, (u64, G2)> = for_while::<g2_scalar_mul_bit_iterate>((bitmask, G2_ZERO), (s1, p));
    let res: G2 = unwrap_left::<(u64, G2)>(out);

    let out: Either<G2, (u64, G2)> = for_while::<g2_scalar_mul_bit_iterate>((bitmask, res), (s2, p));
    let res: G2 = unwrap_left::<(u64, G2)>(out);

    let out: Either<G2, (u64, G2)> = for_while::<g2_scalar_mul_bit_iterate>((bitmask, res), (s3, p));
    let res: G2 = unwrap_left::<(u64, G2)>(out);

    let out: Either<G2, (u64, G2)> = for_while::<g2_scalar_mul_bit_iterate>((bitmask, res), (s4, p));
    let res: G2 = unwrap_left::<(u64, G2)>(out);


    // TODO: Use after array_fold will be fixed
    // let s1bits: [u1; 64] = <u64>::into(s1);
    // let s2bits: [u1; 64] = <u64>::into(s2);
    // let s3bits: [u1; 64] = <u64>::into(s3);
    // let s4bits: [u1; 64] = <u64>::into(s4);

    // let (res, _): (G2, G2) = array_fold::<g2_scalar_mul_bit_iterate, 64>(s1bits, (G2_ZERO, p));
    // let (res, _): (G2, G2) = array_fold::<g2_scalar_mul_bit_iterate, 64>(s2bits, (res, p));
    // let (res, _): (G2, G2) = array_fold::<g2_scalar_mul_bit_iterate, 64>(s3bits, (res, p));
    // let (res, _): (G2, G2) = array_fold::<g2_scalar_mul_bit_iterate, 64>(s4bits, (res, p));

    res
}

#ifdef TESTING

fn test_g2_equal() {
    let a: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (259892889127376095, 15014469608320457438, 7369739921565571232, 14280497310986545915),
            (218153669423612642, 15829644721401476347, 135275955009754999, 6186260357263818337)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    // Positive case
    assert!(g2_eq(a,a));

    let c: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (3227105377675594569, 16713466416663788927, 3547384222912311788, 8498863634002661964),
            (3268844597379358022, 15898291303582770018, 10781848189468128021, 16593100587725389542)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    // Negative case
    assert!(<u1>::into(jet::complement_1(<bool>::into(g2_eq(a,c)))))
}

fn test_g2_negate() {
    let a: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (259892889127376095, 15014469608320457438, 7369739921565571232, 14280497310986545915),
            (218153669423612642, 15829644721401476347, 135275955009754999, 6186260357263818337)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    let c: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (3227105377675594569, 16713466416663788927, 3547384222912311788, 8498863634002661964),
            (3268844597379358022, 15898291303582770018, 10781848189468128021, 16593100587725389542)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    assert!(g2_eq(c, g2_negate(a)))
}

fn test_g2_double() {
    let a: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (259892889127376095, 15014469608320457438, 7369739921565571232, 14280497310986545915),
            (218153669423612642, 15829644721401476347, 135275955009754999, 6186260357263818337)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    let c: G2 = (
        (
            (931673971462479863, 10525653035909234473, 1913830578711471864, 17630134402190704201),
            (1501019713188707749, 8003436368103692424, 5522598211774286726, 6511477200346394438)
        ),
        (
            (2138269384745697989, 3519476597858020239, 13967081505695465073, 2176176012352179042),
            (1012609333683573242, 9547056951775749570, 4134507403839930006, 8567617173400438458)
        ),
        (
            (1440570471695826812, 17949083226952576699, 3700773944358571273, 523814156164210340),
            (1170224043131588829, 14640931442678004897, 1191605545325292958, 5309025039690070977)
        )
    );

    assert!(g2_eq(c, g2_double(a)));
}


fn test_g2_add() {
    let a1: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (259892889127376095, 15014469608320457438, 7369739921565571232, 14280497310986545915),
            (218153669423612642, 15829644721401476347, 135275955009754999, 6186260357263818337)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    let a2: G2 = (
        (
            (3399254737307382285, 15156360776302250688, 354993068800570791, 12056006800691101533),
            (1751834712043914242, 2089421830977324841, 12550223516049860704, 12153321415043324492)
        ),
        (
            (1593903645521446067, 830372614493785679, 6993588422477602090, 17136080484412968551),
            (1103717851843801659, 11277985427487862386, 16838170254174939016, 14247293617486614603)
        ),
        (
            (1480504410545516225, 15337066007286612674, 4301951534844582005, 3750542238558767964),
            (2821929585270398309, 2027672992377529272, 1288191204391499746, 7124722256544728658)
        )
    );

    let c: G2 = (
        (
            (806294532311435681, 16966849532506612447, 13601005733788717258, 9526077749344654941),
            (2344977632681449411, 17522134600010575951, 13870780745431073244, 13616405023392008647)
        ),
        (
            (1095853668639726734, 6965106327438143434, 3262367347718707139, 12894150016148335615),
            (1498563986213191800, 15617202820612272942, 15062495362684868665, 9711094693625605700)
        ),
        (
            (271811025743474830, 2102128009609135670, 2913875892107702620, 6447792654576764502),
            (308666775167543138, 1606177614296478695, 5361119381336739903, 14128114641408750314)
        )
    );

    assert!(g2_eq(c, g2_add(a1, a2)));
    assert!(g2_eq(a1, g2_add(a1, (((0, 0, 0, 0), (0, 0, 0, 0)), ((0, 0, 0, 0), (0, 0, 0, 0)), ((0, 0, 0, 0), (0, 0, 0, 0))))));
}

fn test_g2_sub() {
    let a1: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (259892889127376095, 15014469608320457438, 7369739921565571232, 14280497310986545915),
            (218153669423612642, 15829644721401476347, 135275955009754999, 6186260357263818337)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    let a2: G2 = (
        (
            (3399254737307382285, 15156360776302250688, 354993068800570791, 12056006800691101533),
            (1751834712043914242, 2089421830977324841, 12550223516049860704, 12153321415043324492)
        ),
        (
            (1593903645521446067, 830372614493785679, 6993588422477602090, 17136080484412968551),
            (1103717851843801659, 11277985427487862386, 16838170254174939016, 14247293617486614603)
        ),
        (
            (1480504410545516225, 15337066007286612674, 4301951534844582005, 3750542238558767964),
            (2821929585270398309, 2027672992377529272, 1288191204391499746, 7124722256544728658)
        )
    );

    let c: G2 = (
        (
            (2009529974886317696, 2455497291722502015, 10528195381864600579, 2770901673089481954),
            (1257270879663440253, 3476152936456025118, 15472328864169633748, 13702657425591885961)
        ),
        (
            (2457370253372199024, 3833124680412269174, 5489063178712060824, 21815765683317157),
            (1500902508547560139, 354478879728811845, 16289080629453946417, 5766780022405992469)
        ),
        (
            (271811025743474830, 2102128009609135670, 2913875892107702620, 6447792654576764502),
            (308666775167543138, 1606177614296478695, 5361119381336739903, 14128114641408750314)
        )
    );

    // Normal case
    assert!(g2_eq(c,g2_sub(a1,a2)));

    let c: G2 = (
        (
            (2009529974886317696, 2455497291722502015, 10528195381864600579, 2770901673089481954),
            (1257270879663440253, 3476152936456025118, 15472328864169633748, 13702657425591885961)
        ),
        (
            (2457370253372199024, 3833124680412269174, 5489063178712060824, 21815765683317157),
            (1500902508547560139, 354478879728811845, 16289080629453946417, 5766780022405992469)
        ),
        (
            (3215187241059495835, 11179063941665559079, 8003248252370180400, 16331568290412443377),
            (3178331491635427527, 11675014336978216054, 5556004763141143117, 8651246303580457565)
        )
    );

    // a1 < a2 case
    assert!(g2_eq(c,g2_sub(a2,a1)));

    // a2 is zero case
    assert!(g2_eq(a1, g2_sub(a1, (((0, 0, 0, 0), (0, 0, 0, 0)), ((0, 0, 0, 0), (0, 0, 0, 0)), ((0, 0, 0, 0), (0, 0, 0, 0))))));
}

fn test_g2_scalar_mul() {
    let a: G2 = (
        (
            (2001484014202728412, 8092131012308524788, 3604403482680381408, 1031617175414889245),
            (743656759915915118, 11655094547656086728, 4497771716505590753, 7138295927363345969)
        ),
        (
            (259892889127376095, 15014469608320457438, 7369739921565571232, 14280497310986545915),
            (218153669423612642, 15829644721401476347, 135275955009754999, 6186260357263818337)
        ),
        (
            (489107506417408129, 1786706932022795631, 12859126755793886383, 17262318652709091592),
            (2479830272404203547, 17846133434783767805, 6173819005427061826, 3418802542048399819)
        )
    );

    let c: G2 = (
        (
            (802572288415506527, 15301657960169198999, 1343454645008275785, 11334580586550761537),
            (1380094625221749362, 3869855488643297439, 498255001838928380, 17668357104270263840)
        ),
        (
            (1142842293939565650, 2380328326596508578, 15170203256718755759, 2373084935504652864),
            (1566571373463321140, 5960879974136662677, 16561413104536697458, 12267048271098436273)
        ),
        (
            (852479994742927368, 1787895428777938577, 17767278266614574439, 14579287569636812925),
            (3183236461135041769, 5274262946330869486, 4560430100602268696, 14993558448477838131)
        )
    );

    let s: FieldElement = (0, 0, 0, 5); // Fr element
    
    assert!(g2_eq(c,g2_scalar_mul(a,s)))
}

#endif
#endif
