#ifndef PAIRING_FILE
#define PAIRING_FILE

#include "g1.simf"
#include "g2.simf"
#include "fp12.simf"


// Bitmask (uint64) for positions that represents 1:
// 3 5 14 23 33 38 49 61 65 (65 not included)
#define NAF_MASK_1 11529778279498137640

// Bitmask (uint64) for positions that represents -1:
// 7 10 17 19 25 30 35 44 47 51 55 57 63 
#define NAF_MASK_2 182554150050595968

type LineEval = (Fp12, G2);

fn line_double(q: G2, p: G1) -> LineEval {
    let (qx, qy, qz): (Fp2, Fp2, Fp2) = q;
    let (px, py, _): (FieldElement, FieldElement, FieldElement) = p;

    let tmp0: Fp2 = fp2_square(qx);
    let tmp1: Fp2 = fp2_square(qy);
    let tmp2: Fp2 = fp2_square(tmp1);

    let x: Fp2 = fp2_add(tmp1, qx);
    let x: Fp2 = fp2_square(x);
    let x: Fp2 = fp2_sub(x, tmp0);
    let tmp3: Fp2 = fp2_sub(x, tmp2);
    let tmp3: Fp2 = fp2_double(tmp3);

    let tmp4: Fp2 = fp2_add(tmp0, fp2_double(tmp0));
    let tmp6: Fp2 = fp2_add(qx, tmp4);

    let tmp5: Fp2 = fp2_square(tmp4);
    let X_T: Fp2 = fp2_sub(tmp5, fp2_double(tmp3));

    let Z_T: Fp2 = fp2_add(qy, qz);
    let Z_T: Fp2 = fp2_square(Z_T);
    let Z_T: Fp2 = fp2_sub(Z_T, tmp1);
    let Z_T: Fp2 = fp2_sub(Z_T, fp2_square(qz));

    let Y_T: Fp2 = fp2_sub(tmp3, X_T);
    let Y_T: Fp2 = fp2_mul(Y_T, tmp4);

    let tmp2_8: Fp2 = fp2_double(tmp2);
    let tmp2_8: Fp2 = fp2_double(tmp2_8);
    let tmp2_8: Fp2 = fp2_double(tmp2_8);
    let Y_T: Fp2 = fp2_sub(Y_T, tmp2_8);

    let tmp3: Fp2 = fp2_mul(tmp4, fp2_double(qz));
    let tmp3: Fp2 = fp2_double(tmp3);
    let tmp3: Fp2 = fp2_neg(tmp3);
    let tmp3: Fp2 = fp2_mul_by_b0(tmp3, px);

    let tmp6: Fp2 = fp2_square(tmp6);
    let tmp6: Fp2 = fp2_sub(tmp6, tmp0);
    let tmp6: Fp2 = fp2_sub(tmp6, tmp5);

    let tmp1_4: Fp2 = fp2_double(tmp1);
    let tmp1_4: Fp2 = fp2_double(tmp1_4);
    let tmp6: Fp2 = fp2_sub(tmp6, tmp1_4);

    let tmp0: Fp2 = fp2_mul(Z_T, fp2_square(qz));
    let tmp0: Fp2 = fp2_double(tmp0);
    let tmp0: Fp2 = fp2_mul_by_b0(tmp0, py);

    let l: Fp12 = (
        (tmp0, FP2_ZERO, FP2_ZERO),
        (tmp3, tmp6, FP2_ZERO)
    );

    let T: G2 = (
        X_T, Y_T, Z_T
    );

    (l, T)
}

fn line_add(q: G2, r: G2, p: G1) -> LineEval {
    let (qx, qy, qz): (Fp2, Fp2, Fp2) = q;
    let (rx, ry, rz): (Fp2, Fp2, Fp2) = r;
    let (px, py, _): (FieldElement, FieldElement, FieldElement) = p;

    let t0: Fp2 = fp2_mul(qx, fp2_square(rz));

    let t1: Fp2 = fp2_add(qy, rz);
    let t1: Fp2 = fp2_square(t1);
    let t1: Fp2 = fp2_sub(t1, fp2_square(qy));
    let t1: Fp2 = fp2_sub(t1, fp2_square(rz));
    let t1: Fp2 = fp2_mul(t1, fp2_square(rz));

    let t2: Fp2 = fp2_sub(t0, rx);
    let t3: Fp2 = fp2_square(t2);

    let t4: Fp2 = fp2_double(t3);
    let t4: Fp2 = fp2_double(t4);

    let t5: Fp2 = fp2_mul(t4, t2);
    let t6: Fp2 = fp2_sub(t1, fp2_double(ry));
    let t9: Fp2 = fp2_mul(t6, qx);
    let t7: Fp2 = fp2_mul(rx, t4);

    let X_T: Fp2 = fp2_square(t6);
    let X_T: Fp2 = fp2_sub(X_T, t5);
    let X_T: Fp2 = fp2_sub(X_T, fp2_double(t7));

    let Z_T: Fp2 = fp2_add(rz, t2);
    let Z_T: Fp2 = fp2_square(Z_T);
    let Z_T: Fp2 = fp2_sub(Z_T, fp2_square(rz));
    let Z_T: Fp2 = fp2_sub(Z_T, t3);

    let t10: Fp2 = fp2_add(qy, Z_T);
    let t8: Fp2 = fp2_sub(t7, X_T);
    let t8: Fp2 = fp2_mul(t8, t6);

    let t0: Fp2 = fp2_mul(ry, t5);
    let t0: Fp2 = fp2_double(t0);

    let Y_T: Fp2 = fp2_sub(t8, t0);

    let t10: Fp2 = fp2_square(t10);
    let t10: Fp2 = fp2_sub(t10, fp2_square(qy));
    let t10: Fp2 = fp2_sub(t10, fp2_square(Z_T));

    let t9: Fp2 = fp2_double(t9);
    let t9: Fp2 = fp2_sub(t9, t10);

    let t10: Fp2 = fp2_mul_by_b0(Z_T, py);
    let t10: Fp2 = fp2_double(t10);

    let t6: Fp2 = fp2_neg(t6);
    let t1: Fp2 = fp2_mul_by_b0(t6, px);
    let t1: Fp2 = fp2_double(t1);

    let l: Fp12 = (
        (t10, FP2_ZERO, FP2_ZERO),
        (t1, t9, FP2_ZERO)
    );

    let T: G2 = (
        X_T, Y_T, Z_T
    );

    (l, T)
}

fn final_exponentiation(z: Fp12, z_invert: Fp12) -> Fp12 {
    let t0: Fp12 = fp12_conjugate(z);
    let t0: Fp12 = fp12_mul(t0, z_invert);
    let result: Fp12 = fp12_frobenius_square(t0);
    let result: Fp12 = fp12_mul(result, t0);

    // https://eprint.iacr.org/2015/192.pdf

    let t0: Fp12 = fp12_exponentiation(result);
    let t0: Fp12 = fp12_conjugate(t0);
    let t0: Fp12 = fp12_cyclotomic_square(t0);

    let t2: Fp12 = fp12_exponentiation(t0);
    let t2: Fp12 = fp12_conjugate(t2);
    let t1: Fp12 = fp12_cyclotomic_square(t2);
    let t2: Fp12 = fp12_mul(t2, t1);
    let t2: Fp12 = fp12_mul(t2, result);

    let t1: Fp12 = fp12_exponentiation(t2);
    let t1: Fp12 = fp12_cyclotomic_square(t1);
    let t1: Fp12 = fp12_mul(t1, t2);
    let t1: Fp12 = fp12_conjugate(t1);

    let t3: Fp12 = fp12_conjugate(t1);
    let t1: Fp12 = fp12_cyclotomic_square(t0);
    let t1: Fp12 = fp12_mul(t1, result);
    let t1: Fp12 = fp12_conjugate(t1);
    let t1: Fp12 = fp12_mul(t1, t3);

    let t0: Fp12 = fp12_mul(t0, t1);
    let t2: Fp12 = fp12_mul(t2, t1);

    let t3: Fp12 = fp12_frobenius_square(t1);
    let t2: Fp12 = fp12_mul(t2, t3);

    let t3: Fp12 = fp12_conjugate(result);
    let t3: Fp12 = fp12_mul(t3, t0);

    let t1: Fp12 = fp12_frobenius_cube(t3);
    let t2: Fp12 = fp12_mul(t2, t1);

    let t1: Fp12 = fp12_frobenius(t0);
    let t1: Fp12 = fp12_mul(t1, t2);
    t1
}

fn miller_loop_basic(T: G2, P: G1, f: Fp12) -> LineEval {
    let (line_l, line_t): (Fp12, G2) = line_double(T, P);
    let f: Fp12 = fp12_square(f);
    let f: Fp12 = fp12_mul(f, line_l);
    let T: G2 = line_t;
    (f, T)
}

fn miller_loop_iter(acc: (G2, Fp12, u64), context: (G1, G2), i: u8) -> Either<(G2, Fp12), (G2, Fp12, u64)> {
    let (T, f, bitmask): (G2, Fp12, u64) = acc;
    let (P, Q): (G1, G2) = context;

    match jet::eq_8(i, 64) {
        true => Left((T, f)),   
        false => {
            // Miller loop main iteration operations

            // let (line_l, line_t): (Fp12, G2) = line_double(T, P);
            // let f: Fp12 = fp12_square(f);
            // let f: Fp12 = fp12_mul(f, line_l);
            // let T: G2 = line_t;

            let (f, T): (Fp12, G2) = miller_loop_basic(T, P, f);

            let (T, f): (G2, Fp12) = match jet::some_64(jet::and_64(NAF_MASK_1, bitmask)) {
                true => {
                    // m[i] == 1
                    let (line_l, line_t): (Fp12, G2) = line_add(T, Q, P);
                    (line_t, fp12_mul(f, line_l))
                }
                false => {
                    match jet::some_64(jet::and_64(NAF_MASK_2, bitmask)) {
                        true => {
                            // m[i] == 2
                            let Q_NEG: G2 = g2_negate(Q);
                            let (line_l, line_t): (Fp12, G2) = line_add(T, Q_NEG, P);
                            (line_t, fp12_mul(f, line_l))
                        }
                        // m[i] == 0
                        false => (T, f),
                    }
                }
            };

            // Moving from 63-rd bit in bitmask to 0-th
            let bitmask: u64 = jet::right_shift_64(1, bitmask);

            Right((T, f, bitmask))
        } 
    }
}

fn miller_loop(q: G2, p: G1) -> Fp12 {
    // Moving from 63-rd bit in bitmask to 0-th
    let bitmask: u64 = 9223372036854775808; // 2^63

    //let bitmask: u64 = 1; // 2^0

    let T: G2 = q;
    let f: Fp12 = FP12_ONE;

    // Execute for 64-th position (loop starts from 63). 
    // Because we have 0 in NAF for 64-th position,
    //  we only have to execute basic logic.
    //let (f, T): (Fp12, G2) = miller_loop_basic(T, p, f); 
    
    let out: Either<(G2, Fp12), (G2, Fp12, u64)> = for_while::<miller_loop_iter>((T, f, bitmask), (p, q));
    let (T, f): (G2, Fp12) = unwrap_left::<(G2, Fp12, u64)>(out);

    let (qx, qy, qz): (Fp2, Fp2, Fp2) = q;
    let (px, py, _): (FieldElement, FieldElement, FieldElement) = p;

    let q1x: Fp2 = fp2_conjugate(qx);
    let q1y: Fp2 = fp2_conjugate(qy);
    let q1x: Fp2 = mul_by_non_residue_1_power_2(q1x);
    let q1y: Fp2 = mul_by_non_residue_1_power_3(q1y);

    let q2x: Fp2 = mul_by_non_residue_2_power_2(qx);
    let q2y: Fp2 = mul_by_non_residue_2_power_3(qy);
    let q2y: Fp2 = fp2_neg(q2y);

    let (line_l, line_t): (Fp12, G2) = line_add(T, (q1x, q1y, FP2_ONE), p);
    let f: Fp12 = fp12_mul(f, line_l);
    let T: G2 = line_t;

    let (line_l, line_t): (Fp12, G2) = line_add(T, (q2x, q2y, FP2_ONE), p);
    fp12_mul(f, line_l)
}


#ifndef TESTING

// fn test_t() {
//     let a: Fp12 = fp12_new(
//         fp6_new(fp2_new(1111, 2222), fp2_new(3333, 4444), fp2_new(5555, 6666)),
//         fp6_new(fp2_new(7777, 8888), fp2_new(9999, 0001), fp2_new(1111, 2222))
//     );

//     // Already in Montgomery form
//     let a_inverse: Fp12 = fp12_new(
//         fp6_new (
//             fp2_new (
//                 10322886399694769983787725438643773946836923510314319473519435949799322377601,
//                 7863183687851801163538735521014940442317589460778113851830687739008147204815
//             ), 
//             fp2_new (
//                 14389164047841094096467556825518115909412015899075290733238770930120075598044,
//                 1469009966430237347412144705513984692986939325074731212528871711806716110298
//             ), 
//             fp2_new (
//                 4472412825780660698982871656473726872929691458461320245287924846457203763123,
//                 5341909421263871387825205198895798284522977641729884916438139718352171969747
//             )
//         ),
//         fp6_new (
//             fp2_new (
//                 6061364924929496629046412891162152518166605969941483867466347903031904606064,
//                 19938954118921238902129145919274403196114553480777497664052848257401849652276
//             ), 
//             fp2_new (
//                 9758687230848604844839632455910431220066810074950148597148435118600725864483,
//                 8704644795010780526034397912875403871867477864318638311509586016120041099640
//             ), 
//             fp2_new (
//                 21067231383785863699839952897278193367047902149769651247656120501434768496155,
//                 19926085433652876298552756873218350806391722467864717132980677066102560096146
//             )
//         )
//     );

//     let res: Fp12 = fp12_new(
//         fp6_new (
//             fp2_new (
//                 14925683022804014810631810000986751668441920011159613299940334508508937409470,
//                 19917964437804964363503158914451963789480116764001563204215707647687207070488
//             ), 
//             fp2_new (
//                 11798097442084922180619955888394840078924595301086689829424111905474166596425,
//                 6147421359548191548981434435354936520646028265213551898686264931771448142341
//             ), 
//             fp2_new (
//                 20874588926620247958874850445790598167244490678221534477442199969125927138681,
//                 20213892089544583050574550949085625943866617524765808882057253828673031647067
//             )
//         ),
//         fp6_new (
//             fp2_new (
//                 4079410088347151107522165922308411870689820453546238900559724513782398543460,
//                 837054152980188002011702344570484159600198947691994820330134137826007884580
//             ), 
//             fp2_new (
//                 16443529875841417221780095264359343945320547144534451318844452367851014181321,
//                 5245682446114159728417101344125126723754694504667203014719440630039775951743
//             ), 
//             fp2_new (
//                 11775659996505041381297126303680593817424887142370996395942397347734247256247,
//                 10911864727953050723330745712078971502698063075534621713332717011439216100278
//             )
//         )
//     );

//     assert!(fp12_eq(res, final_exponentiation(a, a_inverse)));
// }

fn test_miller_loop() {
    // Affine
    let a: G1 = (
        (2437184618990599435, 9967461460295048725, 523065847106288149, 4762312042132220243),
        (594740009632949619, 4155084953073764646, 9393803618790697145, 13729987850190402909),
        FP_ZERO
    );

    // Projective
    let b: G2 = (
        (
            (2056513770419527527, 7471512706875894820, 12353292016043059926, 14198858295332109753),
            (1247475978396289395, 7989610938603783500, 17910564013814816979, 8208376203836307886)
        ),
        (
            (2780625897959909976, 12500176327102259920, 14400004413481067226, 3038873508324518298),
            (427541959367055387, 11922945474203155755, 12732514823209126999, 4899900378001561031)
        ),
        (
            (1489943732723647226, 13254171877129764018, 6803726373526347730, 14797337663295721131),
            (2273425530516531152, 15994591960831562213, 13817429962381600795, 3687323464610168706)
        )
    );


    let res_expected: Fp12 = (
        (
            (
                (2869289008428322137,11635625071517294247,14851357650688383596,12228718738557824981),
                (1686381424862098050,10110519108006463596,7895659191649610268,2231821141735942488),
            ), 
            (
                (3208287419186613707,6752648636774833797,10634535895789194442,1621536786982499071),
                (2678190465020230188,12321618724937169201,13308082923525889270,8268148143626450767),
            ),
            (
                (3458289119088018034,7057632081168230811,9811435775661294800,13983443194595223264),
                (1033190138123085914,848252794268980656,3248135443230868440,2296330869438119545),
            )
        ),
        (
            (
                (1685979190051328172,3836366376893519164,17542748743670519757,228174278921663020),
                (117065770115050350,5671126031833810592,5319244876087245504,11163620116403902572),
            ),
            (
                (1200248406970266748,161138912008037404,2443271082800815433,416863816349652999),
                (1009149931988687098,17190806078427306569,2852486723200846829,7106560341603292831),
            ),
            (
                (1187515421340000445,10154344321248230491,13433121233819121471,13299738804381696308),
                (184642437069231037,16199130471425088168,13302362212740826586,7264322832133967827),
            )
        )
    );

    assert!(fp12_eq(res_expected, dbg!(miller_loop(b, a))))
}

#endif
#endif
