#ifndef PAIRING_FILE
#define PAIRING_FILE

#include "g1.simf"
#include "g2.simf"
#include "fp12.simf"

// MILLER_CONST = 6x + 2, where x = 4965661367192848881 (curve parameter).
// Thus, MILLER_CONST = 29793968203157093288, but we remove the most significant bit due to algorithm purposes.
// We receive a 64-bit value, which we use to iterate in the same way as in the scalar multiplication (from most significant bit).
// Why use thi method instead of NAF? The answers is that NAF requires additionall condition to be checked in the Miller loop, 
// so in result, implemntation with NAF works ~5% slower.
#define MILLER_CONST 11347224129447541672

type LineEval = (Fp12, G2);


// Algorithm 26
// https://eprint.iacr.org/2010/354.pdf
fn line_double(q: G2, p: G1) -> LineEval {
    let (qx, qy, qz): (Fp2, Fp2, Fp2) = q;
    let (px, py, _): (FieldElement, FieldElement, FieldElement) = p;

    let tmp0: Fp2 = fp2_square(qx);
    let tmp1: Fp2 = fp2_square(qy);
    let tmp2: Fp2 = fp2_square(tmp1);

    let x: Fp2 = fp2_add(tmp1, qx);
    let x: Fp2 = fp2_square(x);
    let x: Fp2 = fp2_sub(x, tmp0);
    let tmp3: Fp2 = fp2_sub(x, tmp2);
    let tmp3: Fp2 = fp2_double(tmp3);

    let tmp4: Fp2 = fp2_add(tmp0, fp2_double(tmp0));
    let tmp6: Fp2 = fp2_add(qx, tmp4);

    let tmp5: Fp2 = fp2_square(tmp4);
    let X_T: Fp2 = fp2_sub(tmp5, fp2_double(tmp3));

    let Z_T: Fp2 = fp2_add(qy, qz);
    let Z_T: Fp2 = fp2_square(Z_T);
    let Z_T: Fp2 = fp2_sub(Z_T, tmp1);
    let Z_T: Fp2 = fp2_sub(Z_T, fp2_square(qz));

    let Y_T: Fp2 = fp2_sub(tmp3, X_T);
    let Y_T: Fp2 = fp2_mul(Y_T, tmp4);

    let tmp2_8: Fp2 = fp2_double(tmp2);
    let tmp2_8: Fp2 = fp2_double(tmp2_8);
    let tmp2_8: Fp2 = fp2_double(tmp2_8);
    let Y_T: Fp2 = fp2_sub(Y_T, tmp2_8);

    let tmp3: Fp2 = fp2_mul(tmp4, fp2_square(qz));
    let tmp3: Fp2 = fp2_double(tmp3);
    let tmp3: Fp2 = fp2_neg(tmp3);
    let tmp3: Fp2 = fp2_mul_by_b0(tmp3, px);

    let tmp6: Fp2 = fp2_square(tmp6);
    let tmp6: Fp2 = fp2_sub(tmp6, tmp0);
    let tmp6: Fp2 = fp2_sub(tmp6, tmp5);

    let tmp1_4: Fp2 = fp2_double(tmp1);
    let tmp1_4: Fp2 = fp2_double(tmp1_4);
    let tmp6: Fp2 = fp2_sub(tmp6, tmp1_4);

    let tmp0: Fp2 = fp2_mul(Z_T, fp2_square(qz));
    let tmp0: Fp2 = fp2_double(tmp0);
    let tmp0: Fp2 = fp2_mul_by_b0(tmp0, py);

    let l: Fp12 = (
        (tmp0, FP2_ZERO, FP2_ZERO),
        (tmp3, tmp6, FP2_ZERO)
    );

    let T: G2 = (
        X_T, Y_T, Z_T
    );

    (l, T)
}


// Algorithm 27
// https://eprint.iacr.org/2010/354.pdf
fn line_add(q: G2, r: G2, p: G1) -> LineEval {
    let (qx, qy, _): (Fp2, Fp2, Fp2) = q;
    let (rx, ry, rz): (Fp2, Fp2, Fp2) = r;
    let (px, py, _): (FieldElement, FieldElement, FieldElement) = p;

    let t0: Fp2 = fp2_mul(qx, fp2_square(rz));

    let t1: Fp2 = fp2_add(qy, rz);
    let t1: Fp2 = fp2_square(t1);
    let t1: Fp2 = fp2_sub(t1, fp2_square(qy));
    let t1: Fp2 = fp2_sub(t1, fp2_square(rz));
    let t1: Fp2 = fp2_mul(t1, fp2_square(rz));

    let t2: Fp2 = fp2_sub(t0, rx);
    let t3: Fp2 = fp2_square(t2);

    let t4: Fp2 = fp2_double(t3);
    let t4: Fp2 = fp2_double(t4);

    let t5: Fp2 = fp2_mul(t4, t2);
    let t6: Fp2 = fp2_sub(t1, fp2_double(ry));
    let t9: Fp2 = fp2_mul(t6, qx);
    let t7: Fp2 = fp2_mul(rx, t4);

    let X_T: Fp2 = fp2_square(t6);
    let X_T: Fp2 = fp2_sub(X_T, t5);
    let X_T: Fp2 = fp2_sub(X_T, fp2_double(t7));

    let Z_T: Fp2 = fp2_add(rz, t2);
    let Z_T: Fp2 = fp2_square(Z_T);
    let Z_T: Fp2 = fp2_sub(Z_T, fp2_square(rz));
    let Z_T: Fp2 = fp2_sub(Z_T, t3);

    let t10: Fp2 = fp2_add(qy, Z_T);
    let t8: Fp2 = fp2_sub(t7, X_T);
    let t8: Fp2 = fp2_mul(t8, t6);

    let t0: Fp2 = fp2_mul(ry, t5);
    let t0: Fp2 = fp2_double(t0);

    let Y_T: Fp2 = fp2_sub(t8, t0);

    let t10: Fp2 = fp2_square(t10);
    let t10: Fp2 = fp2_sub(t10, fp2_square(qy));
    let t10: Fp2 = fp2_sub(t10, fp2_square(Z_T));

    let t9: Fp2 = fp2_double(t9);
    let t9: Fp2 = fp2_sub(t9, t10);

    let t10: Fp2 = fp2_mul_by_b0(Z_T, py);
    let t10: Fp2 = fp2_double(t10);

    let t6: Fp2 = fp2_neg(t6);
    let t1: Fp2 = fp2_mul_by_b0(t6, px);
    let t1: Fp2 = fp2_double(t1);

    let l: Fp12 = (
        (t10, FP2_ZERO, FP2_ZERO),
        (t1, t9, FP2_ZERO)
    );

    let T: G2 = (
        X_T, Y_T, Z_T
    );

    (l, T)
}

fn final_exponentiation(z: Fp12, z_invert: Fp12) -> Fp12 {
    let t0: Fp12 = fp12_conjugate(z);
    let t0: Fp12 = fp12_mul(t0, z_invert);
    let result: Fp12 = fp12_frobenius_square(t0);
    let result: Fp12 = fp12_mul(result, t0);

    // https://eprint.iacr.org/2015/192.pdf

    let t0: Fp12 = fp12_exponentiation(result);
    let t0: Fp12 = fp12_conjugate(t0);
    let t0: Fp12 = fp12_cyclotomic_square(t0);

    let t2: Fp12 = fp12_exponentiation(t0);
    let t2: Fp12 = fp12_conjugate(t2);
    let t1: Fp12 = fp12_cyclotomic_square(t2);
    let t2: Fp12 = fp12_mul(t2, t1);
    let t2: Fp12 = fp12_mul(t2, result);

    let t1: Fp12 = fp12_exponentiation(t2);
    let t1: Fp12 = fp12_cyclotomic_square(t1);
    let t1: Fp12 = fp12_mul(t1, t2);
    let t1: Fp12 = fp12_conjugate(t1);

    let t3: Fp12 = fp12_conjugate(t1);
    let t1: Fp12 = fp12_cyclotomic_square(t0);
    let t1: Fp12 = fp12_mul(t1, result);
    let t1: Fp12 = fp12_conjugate(t1);
    let t1: Fp12 = fp12_mul(t1, t3);

    let t0: Fp12 = fp12_mul(t0, t1);
    let t2: Fp12 = fp12_mul(t2, t1);

    let t3: Fp12 = fp12_frobenius_square(t1);
    let t2: Fp12 = fp12_mul(t2, t3);

    let t3: Fp12 = fp12_conjugate(result);
    let t3: Fp12 = fp12_mul(t3, t0);

    let t1: Fp12 = fp12_frobenius_cube(t3);
    let t2: Fp12 = fp12_mul(t2, t1);

    let t1: Fp12 = fp12_frobenius(t0);
    let t1: Fp12 = fp12_mul(t1, t2);
    t1
}

fn miller_loop_basic(T: G2, P: G1, f: Fp12) -> LineEval {
    let (line_l, line_t): (Fp12, G2) = line_double(T, P);
    let f: Fp12 = fp12_square(f);
    let f: Fp12 = fp12_mul(f, line_l);
    let T: G2 = line_t;
    (f, T)
}

fn miller_loop_iter(acc: (G2, Fp12, u64), context: (G1, G2), i: u8) -> Either<(G2, Fp12), (G2, Fp12, u64)> {
    let (T, f, bitmask): (G2, Fp12, u64) = acc;
    let (P, Q): (G1, G2) = context;

    match jet::eq_8(i, 64) {
        true => Left((T, f)),
        false => {
            // Miller loop main iteration operations

            let (f, T): (Fp12, G2) = miller_loop_basic(T, P, f);

            let (T, f): (G2, Fp12) = match jet::some_64(jet::and_64(MILLER_CONST, bitmask)) {
                true => {
                    // m[i] == 1
                    let (line_l, line_t): (Fp12, G2) = line_add(Q, T, P);
                    (line_t, fp12_mul(f, line_l))
                },
                false => (T, f),
            };

            // Moving from 63-rd bit in bitmask to 0-th
            let bitmask: u64 = jet::right_shift_64(1, bitmask);
            Right((T, f, bitmask))
        } 
    }
}

fn miller_loop(q: G2, p: G1) -> Fp12 {
    // Moving from 63-rd bit in bitmask to 0-th
    let bitmask: u64 = 9223372036854775808; // 2^63

    let T: G2 = q;
    let f: Fp12 = FP12_ONE;
    
    let out: Either<(G2, Fp12), (G2, Fp12, u64)> = for_while::<miller_loop_iter>((T, f, bitmask), (p, q));
    let (T, f): (G2, Fp12) = unwrap_left::<(G2, Fp12, u64)>(out);

    let (qx, qy, _): (Fp2, Fp2, Fp2) = q;

    let q1x: Fp2 = fp2_conjugate(qx);
    let q1y: Fp2 = fp2_conjugate(qy);
    let q1x: Fp2 = mul_by_non_residue_1_power_2(q1x);
    let q1y: Fp2 = mul_by_non_residue_1_power_3(q1y);

    let q2x: Fp2 = fp2_conjugate(q1x);
    let q2y: Fp2 = fp2_conjugate(q1y);
    let q2x: Fp2 = mul_by_non_residue_1_power_2(q2x);
    let q2y: Fp2 = mul_by_non_residue_1_power_3(q2y);
    let q2y: Fp2 = fp2_neg(q2y);

    let (line_l, line_t): (Fp12, G2) = line_add((q1x, q1y, FP2_ONE), T, p);
    let f: Fp12 = fp12_mul(f, line_l);
    let T: G2 = line_t;

    let (line_l, line_t): (Fp12, G2) = line_add((q2x, q2y, FP2_ONE), T, p);
    fp12_mul(f, line_l)
}


// Evaluates Ate Optimal pairing, 
// requries invert value for miller loop result to be provided
// because we dont want to evaluate it here.
fn pair(Q: G2, P: G1, miller_loop_inv: Fp12) -> Fp12 {
    let res: Fp12 = miller_loop(Q, P);
    assert!(fp12_eq(FP12_ONE, fp12_mul(res, miller_loop_inv)));
    final_exponentiation(res, miller_loop_inv)
}

#ifndef TESTING

// fn test_t() {
//     let a: Fp12 = fp12_new(
//         fp6_new(fp2_new(1111, 2222), fp2_new(3333, 4444), fp2_new(5555, 6666)),
//         fp6_new(fp2_new(7777, 8888), fp2_new(9999, 0001), fp2_new(1111, 2222))
//     );

//     // Already in Montgomery form
//     let a_inverse: Fp12 = fp12_new(
//         fp6_new (
//             fp2_new (
//                 10322886399694769983787725438643773946836923510314319473519435949799322377601,
//                 7863183687851801163538735521014940442317589460778113851830687739008147204815
//             ), 
//             fp2_new (
//                 14389164047841094096467556825518115909412015899075290733238770930120075598044,
//                 1469009966430237347412144705513984692986939325074731212528871711806716110298
//             ), 
//             fp2_new (
//                 4472412825780660698982871656473726872929691458461320245287924846457203763123,
//                 5341909421263871387825205198895798284522977641729884916438139718352171969747
//             )
//         ),
//         fp6_new (
//             fp2_new (
//                 6061364924929496629046412891162152518166605969941483867466347903031904606064,
//                 19938954118921238902129145919274403196114553480777497664052848257401849652276
//             ), 
//             fp2_new (
//                 9758687230848604844839632455910431220066810074950148597148435118600725864483,
//                 8704644795010780526034397912875403871867477864318638311509586016120041099640
//             ), 
//             fp2_new (
//                 21067231383785863699839952897278193367047902149769651247656120501434768496155,
//                 19926085433652876298552756873218350806391722467864717132980677066102560096146
//             )
//         )
//     );

//     let res: Fp12 = fp12_new(
//         fp6_new (
//             fp2_new (
//                 14925683022804014810631810000986751668441920011159613299940334508508937409470,
//                 19917964437804964363503158914451963789480116764001563204215707647687207070488
//             ), 
//             fp2_new (
//                 11798097442084922180619955888394840078924595301086689829424111905474166596425,
//                 6147421359548191548981434435354936520646028265213551898686264931771448142341
//             ), 
//             fp2_new (
//                 20874588926620247958874850445790598167244490678221534477442199969125927138681,
//                 20213892089544583050574550949085625943866617524765808882057253828673031647067
//             )
//         ),
//         fp6_new (
//             fp2_new (
//                 4079410088347151107522165922308411870689820453546238900559724513782398543460,
//                 837054152980188002011702344570484159600198947691994820330134137826007884580
//             ), 
//             fp2_new (
//                 16443529875841417221780095264359343945320547144534451318844452367851014181321,
//                 5245682446114159728417101344125126723754694504667203014719440630039775951743
//             ), 
//             fp2_new (
//                 11775659996505041381297126303680593817424887142370996395942397347734247256247,
//                 10911864727953050723330745712078971502698063075534621713332717011439216100278
//             )
//         )
//     );

//     assert!(fp12_eq(res, final_exponentiation(a, a_inverse)));
// }

fn test_pair() {
    // // Affine G1 * 4
    let a1: G1 = (
        (2757464229766823725, 14568032333222212778, 6389672123628129923, 6911879846173232518),
        (3069905374919779552, 7530437222749810606, 16589401835404634450, 15876700746134771758),
        FP_ONE
    );

    // Affine G2 * 5
    let b1: G2 = (
        (
            (162576330247084177, 6738075930381345404, 16403655048515839069, 8650504425757902524),
            (1417438596460495847, 10691329897643206798, 16388134564287287564, 1783407446529906203)
        ),
        (
            (3356073820233321356, 4619146372238416683, 38417099133583275, 18420908591769930154),
            (1235775345713159650, 9653266774138959742, 3502473321109216397, 17694947990916007242)
        ),
        FP2_ONE
    );

    let miller_loop_inverse_1: Fp12 = (
       (
            (
                (399676745551429168,12255879348001238513,17180595066356977610,9601441161323204933),
                (3107895829717611221,9942347504255527837,17576342825921590060,16448862916293780754)
            ),
            (
                (1965289759354168429,1964686008351614299,4327691595402965696,14882401127065090568),
                (1023928062735919672,16720124479240457377,17564167850289272214,15954396477494974146)
            ),
            (
                (2746645926614967607,13213376308837561950,5873289170628714941,11623685140323650608),
                (683398043413291369,751495088301981075,1639761148416483612,9808687309776839885)
            )
        ),
        (
            (
                (2749684504708030456,9522113939867121636,18089974255525083334,10687885980681695415),
                (3308345905279674882,11343417561835621247,17345015958111944143,4221820412613436556)
            ),
            (
                (2579720714176794311,8662363377039445914,14871151129411312939,11305692184443006722),
                (2488035952845080054,7564083766844475319,520078754824186880,7673217146821933524)
            ),
            (
                (1234604147754991283,6718764739949648381,16278534201367100962,9611827382755761101),
                (3032962931362982590,13241281831965433462,13672724070294007608,5029326922966067075)
            )
        )
    );

    // Affine G1 * 2
    let a2: G1 = (
        (1378791528466284877, 14015815241649799916, 13550016860984857705, 16214190896527698488),
        (316464129134141481, 13281191951274694749, 10917124144477883021, 4332616871279656263),
        FP_ZERO
    );

    // Affine G2 * 10
    let b2: G2 = (
        (
            (3306825394810095596, 15035391159583992441, 11086700741565266450, 7291404789479094031),
            (515734227054124018, 726042534331094586, 385163545099919124, 17891978150502388586)
        ),
        (
            (1028641656060462153, 16075828784698996878, 9692101503946202506, 7283093440532780226),
            (2194329571587204288, 15978176232218692766, 8466904716475248347, 2357982617944136400)
        ),
        FP2_ONE
    );

    let miller_loop_inverse_2: Fp12 = (
       (
            (
                (615780412477299528,16625791576738392392,6313715467915418507,3074702148459172579),
                (803299819687398175,15583277644096652078,16039968991310099614,17566314033471516342)
            ),
            (
                (422354057558194318,17301660677726051451,13869000504134472545,17126875690604621480),
                (3220019868874510406,17083716251024583321,3510508985546415519,6650234651536258137)
            ),
            (
                (905514513733950033,8716953349834765869,818631901313828035,9221681527191719141),
                (1631934993934289420,15887910632659380352,2912308849635094245,10694054772944753727)
            )
        ),
        (
            (
                (142337796574137138,7435946720642850214,15851357602850941008,12339691611081743943),
                (3005422621013411731,13141009228113005862,2160496652909167012,16842349639466529086)
            ),
            (
                (816550606598271891,12950510639235287379,10821877106535136534,15123660739989829604),
                (1146206980726924321,5246757936001290206,10316729028537174897,2600737294670404968)
            ),
            (
                (274968840930395832,1075236923689494946,3113418278095951546,10780936766350405090),
                (3085552794677980108,3871316836482909965,10732776064332175138,2294171832820157286)
            )
        )
    );

    //let z: Fp12 = dbg!(miller_loop(b2, a2));

    //let _: Fp12 = dbg!(pair(b1, a1, miller_loop_inverse_1));
    let _: Fp12 = dbg!(pair(b2, a2, miller_loop_inverse_2));


    // assert!(fp12_eq(dbg!(pair(b1, a1, miller_loop_inverse_1)), dbg!(pair(b2, a2, miller_loop_inverse_2))))
}

#endif
#endif

